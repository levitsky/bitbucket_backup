{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/14/comments/53730677.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/14/_/diff#comment-53730677"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 14, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/14.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/14"}}, "title": "Compression factoring"}, "content": {"raw": "Awesome!\n\nOne nit I see now is that the `ArrayConversionMixin` doesn't do its thing when decoding is deferred (`_convert_array` is only called with `decode_binary=True`). What I feel the user would expect is that `dtype` argument is compatible with `decode_binary=False`. Since it makes sense to do the conversion after the record's `decode()` is called, it looks like it's hard to do by overriding methods of `ArrayConversionMixin` and easier to do by subclassing `binary_array_record`.\nThe sanest way I was able to do that is like this:\n\n```\n#!diff\n\n\ndiff -r c224aee7ccf4 pyteomics/auxiliary.py\n--- a/pyteomics/auxiliary.py    Mon Jan 15 14:44:36 2018 -0500\n+++ b/pyteomics/auxiliary.py    Tue Jan 16 01:24:18 2018 +0300\n@@ -1435,6 +1435,23 @@\n     output = np.frombuffer(decoded_source, dtype=dtype)\n     return output\n \n+class binary_array_record(namedtuple(\n+    \"binary_array_record\", (\"data\", \"compression\", \"dtype\", \"source\", \"key\"))):\n+    \"\"\"Hold all of the information about a base64 encoded array needed to\n+    decode the array.\n+    \"\"\"\n+\n+    def decode(self):\n+        \"\"\"Decode :attr:`data` into a numerical array\n+\n+        Returns\n+        -------\n+        np.ndarray\n+        \"\"\"\n+        if self.key is None:\n+            return self.source._decode_record(self)\n+        else:\n+            return self.source._decode_record(self)[self.key]\n \n class BinaryDataArrayTransformer(object):\n     \"\"\"A base class that provides methods for reading\n@@ -1451,23 +1468,7 @@\n         'zlib compression': zlib.decompress,\n     }\n \n-    class binary_array_record(namedtuple(\n-        \"binary_array_record\", (\"data\", \"compression\", \"dtype\", \"source\", \"key\"))):\n-        \"\"\"Hold all of the information about a base64 encoded array needed to\n-        decode the array.\n-        \"\"\"\n-\n-        def decode(self):\n-            \"\"\"Decode :attr:`data` into a numerical array\n-\n-            Returns\n-            -------\n-            np.ndarray\n-            \"\"\"\n-            if self.key is None:\n-                return self.source._decode_record(self)\n-            else:\n-                return self.source._decode_record(self)[self.key]\n+    binary_array_record = binary_array_record\n \n     def _make_record(self, data, compression, dtype, key=None):\n         return self.binary_array_record(data, compression, dtype, self, key)\ndiff -r c224aee7ccf4 pyteomics/xml.py\n--- a/pyteomics/xml.py  Mon Jan 15 14:44:36 2018 -0500\n+++ b/pyteomics/xml.py  Tue Jan 16 01:24:18 2018 +0300\n@@ -42,7 +42,7 @@\n from .auxiliary import FileReader, PyteomicsError, basestring, _file_obj\n from .auxiliary import unitint, unitfloat, unitstr\n from .auxiliary import _keepstate_method as _keepstate\n-from .auxiliary import BinaryDataArrayTransformer\n+from .auxiliary import BinaryDataArrayTransformer, binary_array_record\n try: # Python 2.7\n     from urllib2 import urlopen, URLError\n except ImportError: # Python 3.x\n@@ -1079,9 +1079,15 @@\n         with cls(path, use_index=True) as inst:\n             inst.write_byte_offsets()\n \n+class converting_binary_array_record(binary_array_record):\n+    def decode(self):\n+        decoded = super(converting_binary_array_record, self).decode()\n+        return self.source._convert_array(self.key, decoded)\n+\n class ArrayConversionMixin(BinaryDataArrayTransformer):\n     _dtype_dict = {}\n     _array_keys = ['m/z array', 'intensity array']\n+    binary_array_record = converting_binary_array_record\n \n     def __init__(self, *args, **kwargs):\n         self._dtype_dict.setdefault(None, None)\n@@ -1099,6 +1105,8 @@\n             return array.astype(dtype)\n         return array\n \n+    \n+\n _trafoxml_schema_defaults = {'bools': set(),\n      'charlists': set(),\n      'floatlists': set(),\n```\n\nDoes it make sense to you? Is there a better way?", "markup": "markdown", "html": "<p>Awesome!</p>\n<p>One nit I see now is that the <code>ArrayConversionMixin</code> doesn't do its thing when decoding is deferred (<code>_convert_array</code> is only called with <code>decode_binary=True</code>). What I feel the user would expect is that <code>dtype</code> argument is compatible with <code>decode_binary=False</code>. Since it makes sense to do the conversion after the record's <code>decode()</code> is called, it looks like it's hard to do by overriding methods of <code>ArrayConversionMixin</code> and easier to do by subclassing <code>binary_array_record</code>.\nThe sanest way I was able to do that is like this:</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r c224aee7ccf4 pyteomics/auxiliary.py</span>\n<span class=\"gd\">--- a/pyteomics/auxiliary.py    Mon Jan 15 14:44:36 2018 -0500</span>\n<span class=\"gi\">+++ b/pyteomics/auxiliary.py    Tue Jan 16 01:24:18 2018 +0300</span>\n<span class=\"gu\">@@ -1435,6 +1435,23 @@</span>\n     output = np.frombuffer(decoded_source, dtype=dtype)\n     return output\n\n<span class=\"gi\">+class binary_array_record(namedtuple(</span>\n<span class=\"gi\">+    &quot;binary_array_record&quot;, (&quot;data&quot;, &quot;compression&quot;, &quot;dtype&quot;, &quot;source&quot;, &quot;key&quot;))):</span>\n<span class=\"gi\">+    &quot;&quot;&quot;Hold all of the information about a base64 encoded array needed to</span>\n<span class=\"gi\">+    decode the array.</span>\n<span class=\"gi\">+    &quot;&quot;&quot;</span>\n<span class=\"gi\">+</span>\n<span class=\"gi\">+    def decode(self):</span>\n<span class=\"gi\">+        &quot;&quot;&quot;Decode :attr:`data` into a numerical array</span>\n<span class=\"gi\">+</span>\n<span class=\"gi\">+        Returns</span>\n<span class=\"gi\">+        -------</span>\n<span class=\"gi\">+        np.ndarray</span>\n<span class=\"gi\">+        &quot;&quot;&quot;</span>\n<span class=\"gi\">+        if self.key is None:</span>\n<span class=\"gi\">+            return self.source._decode_record(self)</span>\n<span class=\"gi\">+        else:</span>\n<span class=\"gi\">+            return self.source._decode_record(self)[self.key]</span>\n\n class BinaryDataArrayTransformer(object):\n     &quot;&quot;&quot;A base class that provides methods for reading\n<span class=\"gu\">@@ -1451,23 +1468,7 @@</span>\n         &#39;zlib compression&#39;: zlib.decompress,\n     }\n\n<span class=\"gd\">-    class binary_array_record(namedtuple(</span>\n<span class=\"gd\">-        &quot;binary_array_record&quot;, (&quot;data&quot;, &quot;compression&quot;, &quot;dtype&quot;, &quot;source&quot;, &quot;key&quot;))):</span>\n<span class=\"gd\">-        &quot;&quot;&quot;Hold all of the information about a base64 encoded array needed to</span>\n<span class=\"gd\">-        decode the array.</span>\n<span class=\"gd\">-        &quot;&quot;&quot;</span>\n<span class=\"gd\">-</span>\n<span class=\"gd\">-        def decode(self):</span>\n<span class=\"gd\">-            &quot;&quot;&quot;Decode :attr:`data` into a numerical array</span>\n<span class=\"gd\">-</span>\n<span class=\"gd\">-            Returns</span>\n<span class=\"gd\">-            -------</span>\n<span class=\"gd\">-            np.ndarray</span>\n<span class=\"gd\">-            &quot;&quot;&quot;</span>\n<span class=\"gd\">-            if self.key is None:</span>\n<span class=\"gd\">-                return self.source._decode_record(self)</span>\n<span class=\"gd\">-            else:</span>\n<span class=\"gd\">-                return self.source._decode_record(self)[self.key]</span>\n<span class=\"gi\">+    binary_array_record = binary_array_record</span>\n\n     def _make_record(self, data, compression, dtype, key=None):\n         return self.binary_array_record(data, compression, dtype, self, key)\n<span class=\"gh\">diff -r c224aee7ccf4 pyteomics/xml.py</span>\n<span class=\"gd\">--- a/pyteomics/xml.py  Mon Jan 15 14:44:36 2018 -0500</span>\n<span class=\"gi\">+++ b/pyteomics/xml.py  Tue Jan 16 01:24:18 2018 +0300</span>\n<span class=\"gu\">@@ -42,7 +42,7 @@</span>\n from .auxiliary import FileReader, PyteomicsError, basestring, _file_obj\n from .auxiliary import unitint, unitfloat, unitstr\n from .auxiliary import _keepstate_method as _keepstate\n<span class=\"gd\">-from .auxiliary import BinaryDataArrayTransformer</span>\n<span class=\"gi\">+from .auxiliary import BinaryDataArrayTransformer, binary_array_record</span>\n try: # Python 2.7\n     from urllib2 import urlopen, URLError\n except ImportError: # Python 3.x\n<span class=\"gu\">@@ -1079,9 +1079,15 @@</span>\n         with cls(path, use_index=True) as inst:\n             inst.write_byte_offsets()\n\n<span class=\"gi\">+class converting_binary_array_record(binary_array_record):</span>\n<span class=\"gi\">+    def decode(self):</span>\n<span class=\"gi\">+        decoded = super(converting_binary_array_record, self).decode()</span>\n<span class=\"gi\">+        return self.source._convert_array(self.key, decoded)</span>\n<span class=\"gi\">+</span>\n class ArrayConversionMixin(BinaryDataArrayTransformer):\n     _dtype_dict = {}\n     _array_keys = [&#39;m/z array&#39;, &#39;intensity array&#39;]\n<span class=\"gi\">+    binary_array_record = converting_binary_array_record</span>\n\n     def __init__(self, *args, **kwargs):\n         self._dtype_dict.setdefault(None, None)\n<span class=\"gu\">@@ -1099,6 +1105,8 @@</span>\n             return array.astype(dtype)\n         return array\n\n<span class=\"gi\">+    </span>\n<span class=\"gi\">+</span>\n _trafoxml_schema_defaults = {&#39;bools&#39;: set(),\n      &#39;charlists&#39;: set(),\n      &#39;floatlists&#39;: set(),\n</pre></div>\n\n\n<p>Does it make sense to you? Is there a better way?</p>", "type": "rendered"}, "created_on": "2018-01-15T22:26:10.607148+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2018-01-15T22:26:10.609142+00:00", "type": "pullrequest_comment", "id": 53730677}