{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/14/comments/53950253.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/14/_/diff#comment-53950253"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 14, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/14.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/14"}}, "title": "Compression factoring"}, "content": {"raw": "I think a better solution is to accept that records are not synonymous with the arrays they encode much earlier in the abstraction, and to push the logic that completes the conversion from record to array up the class hierarchy. Then we can associate keys with arrays in both mzML and mzXML without breaking how they are unpacked, as this would have to in order to properly encode things.\n\nWe already have the `binary_array_record.decode` method calling `BinaryDataArrayTransformer._decode_record` which begins the process, and is currently just a wrapper around `decode_data_array` with the unpacked record. We could either repeatedly overload this method every time we want to add more processing to it (leading to lots of super calls) or we can decompose it into multiple methods, some of which are no-ops on the base classes. Since the most abstract forms are never used directly, \n\n```python\nclass BinaryDataArrayTransformer(object):\n    ...\n    def _decode_record(self, record):\n        array = self.decode_data_array(\n            record.data, record.compression, record.dtype)\n        return self._finalize_record_conversion(array, record)\n\n    def _finalize_record_conversion(self, array, record):\n        return array\n```\nInstead of overriding `_decode_record` directly and calling super() inside, we override one\nstep inside and use it to inject a call to `_convert_array` on the record.\n```python\nclass ArrayConversionMixin(BinaryDataArrayTransformer):\n    ...\n    def _finalize_record_conversion(self, array, record):\n        key = record.key\n        return self._convert_array(key, array)\n```\nThen instead of needing to call super() and find another way to encode how to unpack the compound array in mzXML files, we can do it in one pass here again with one method override.\n```python\nclass MzXML(xml.ArrayConversionMixin, xml.IndexSavingXML):\n    ...\n    def _finalize_record_conversion(self, array, record):\n        key = record.key\n        return self._convert_array(key, array[key])\n```\nIf this process were a bit more complex than injecting a single method call though, using super would probably be less work to maintain in the future, but it's hard to see that happening. The newer binary formats like mz5, mzdb and mzmlb retain the distinct binary blobs for each array.", "markup": "markdown", "html": "<p>I think a better solution is to accept that records are not synonymous with the arrays they encode much earlier in the abstraction, and to push the logic that completes the conversion from record to array up the class hierarchy. Then we can associate keys with arrays in both mzML and mzXML without breaking how they are unpacked, as this would have to in order to properly encode things.</p>\n<p>We already have the <code>binary_array_record.decode</code> method calling <code>BinaryDataArrayTransformer._decode_record</code> which begins the process, and is currently just a wrapper around <code>decode_data_array</code> with the unpacked record. We could either repeatedly overload this method every time we want to add more processing to it (leading to lots of super calls) or we can decompose it into multiple methods, some of which are no-ops on the base classes. Since the most abstract forms are never used directly, </p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">BinaryDataArrayTransformer</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_decode_record</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">record</span><span class=\"p\">):</span>\n        <span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">decode_data_array</span><span class=\"p\">(</span>\n            <span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">compression</span><span class=\"p\">,</span> <span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_finalize_record_conversion</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"n\">record</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_finalize_record_conversion</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"n\">record</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">array</span>\n</pre></div>\n\n\n<p>Instead of overriding <code>_decode_record</code> directly and calling super() inside, we override one\nstep inside and use it to inject a call to <code>_convert_array</code> on the record.</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">ArrayConversionMixin</span><span class=\"p\">(</span><span class=\"n\">BinaryDataArrayTransformer</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_finalize_record_conversion</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"n\">record</span><span class=\"p\">):</span>\n        <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">key</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_convert_array</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">array</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>Then instead of needing to call super() and find another way to encode how to unpack the compound array in mzXML files, we can do it in one pass here again with one method override.</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MzXML</span><span class=\"p\">(</span><span class=\"n\">xml</span><span class=\"o\">.</span><span class=\"n\">ArrayConversionMixin</span><span class=\"p\">,</span> <span class=\"n\">xml</span><span class=\"o\">.</span><span class=\"n\">IndexSavingXML</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_finalize_record_conversion</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"n\">record</span><span class=\"p\">):</span>\n        <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">key</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_convert_array</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">array</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">])</span>\n</pre></div>\n\n\n<p>If this process were a bit more complex than injecting a single method call though, using super would probably be less work to maintain in the future, but it's hard to see that happening. The newer binary formats like mz5, mzdb and mzmlb retain the distinct binary blobs for each array.</p>", "type": "rendered"}, "created_on": "2018-01-17T19:47:29.860772+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2018-01-17T19:47:30.001497+00:00", "type": "pullrequest_comment", "id": 53950253}