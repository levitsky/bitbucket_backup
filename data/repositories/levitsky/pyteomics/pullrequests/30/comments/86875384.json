{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/30/comments/86875384.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/30/_/diff#comment-86875384"}}, "parent": {"id": 86869104, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/30/comments/86869104.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/30/_/diff#comment-86869104"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 30, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/30.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/30"}}, "title": "Feature: Implement XML parameter repackaging for detecting empty parameters"}, "content": {"raw": "I\u2019m afraid hiding the \u201cname\u201d key may defeat the purpose of convenience, because the user won\u2019t go for the \u201cname\u201d key at all if it\u2019s not visible.\n\nAs for the tag-specific handling, this feels like the proper approach. It could be implementing differently, though, once again raising the question of convenience vs simplicity or, in this case, versatility. In your example, the handler gets passed the info dict. Alternatively, it can get the element itself \\(most versatile, most work by the user\\) or at the other extreme, we can simply redefine `_promote_empty_param_to_name`\u00a0 and `_remove_duplicate_keys` on a tag-specific basis \\(least work, least versatile\\).\n\nYour example looks like a sane trade-off, though, only doing post-processing on a pre-formed dict should be good enough. What would be the way to get a list of tags where the \u201cname\u201d substitution or complete flattening are safe?", "markup": "markdown", "html": "<p>I\u2019m afraid hiding the \u201cname\u201d key may defeat the purpose of convenience, because the user won\u2019t go for the \u201cname\u201d key at all if it\u2019s not visible.</p>\n<p>As for the tag-specific handling, this feels like the proper approach. It could be implementing differently, though, once again raising the question of convenience vs simplicity or, in this case, versatility. In your example, the handler gets passed the info dict. Alternatively, it can get the element itself (most versatile, most work by the user) or at the other extreme, we can simply redefine <code>_promote_empty_param_to_name</code>\u00a0 and <code>_remove_duplicate_keys</code> on a tag-specific basis (least work, least versatile).</p>\n<p>Your example looks like a sane trade-off, though, only doing post-processing on a pre-formed dict should be good enough. What would be the way to get a list of tags where the \u201cname\u201d substitution or complete flattening are safe?</p>", "type": "rendered"}, "created_on": "2019-01-02T14:03:18.461748+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2019-01-02T14:03:18.473489+00:00", "type": "pullrequest_comment", "id": 86875384}