{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/30/comments/86869104.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/30/_/diff#comment-86869104"}}, "parent": {"id": 86867360, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/30/comments/86867360.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/30/_/diff#comment-86867360"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 30, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/30.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/30"}}, "title": "Feature: Implement XML parameter repackaging for detecting empty parameters"}, "content": {"raw": "I think the safest choice is duplication. There are other options involving abstraction. \n\nThe first is to return a `dict`-like object rather than a plain `dict` which handles queries for the `\"name\"` key differently. \n\n```python\nclass NameDict(dict):\n    def __missing__(self, key):\n        if key == \"name\":\n            return self._name_interpolation()\n        else:\n            raise KeyError(key)\n    \n    def _name_interpolation(self):\n        # guesswork\n```\n\nThis may run the risk of looking \"magical\" to the user because they won't see the `\"name\"` key, but it will avoid API breakages. We'd have to determine whether `__contains__`, `keys`, `values`, and `items` would need to be patched as well, and in that case it might make more sense to take the duplication route instead.\n\nThe second is to employ tag-specific processes in `get_info`. Right now, `get_info` is mostly tag-agnostic, with the exception of \\*Param tags and root elements. We can add a \"handler registry\" to the parser system that look up methods to call when processing specific tags.\n\n```python\nclass XML(...):\n   def _get_info(self, element, *args, **kwargs):\n       tag_name = _local_name(element)\n       info = {}\n       ...\n       handler = self._handler_registry.get(tag_name)\n       if handler is not None:\n           info = handler(info)\n       ...\n       return info\n```\n\nThis doesn\u2019t cause any duplication or type inconsistency, but it does mean that not all XML is processed the same way, and that means that ergonomic choices have to be explicitly specified, either by us or the user. ", "markup": "markdown", "html": "<p>I think the safest choice is duplication. There are other options involving abstraction. </p>\n<p>The first is to return a <code>dict</code>-like object rather than a plain <code>dict</code> which handles queries for the <code>\"name\"</code> key differently. </p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">NameDict</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__missing__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;name&quot;</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name_interpolation</span><span class=\"p\">()</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">KeyError</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_name_interpolation</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># guesswork</span>\n</pre></div>\n\n\n<p>This may run the risk of looking \"magical\" to the user because they won't see the <code>\"name\"</code> key, but it will avoid API breakages. We'd have to determine whether <code>__contains__</code>, <code>keys</code>, <code>values</code>, and <code>items</code> would need to be patched as well, and in that case it might make more sense to take the duplication route instead.</p>\n<p>The second is to employ tag-specific processes in <code>get_info</code>. Right now, <code>get_info</code> is mostly tag-agnostic, with the exception of *Param tags and root elements. We can add a \"handler registry\" to the parser system that look up methods to call when processing specific tags.</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">XML</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">):</span>\n   <span class=\"k\">def</span> <span class=\"nf\">_get_info</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n       <span class=\"n\">tag_name</span> <span class=\"o\">=</span> <span class=\"n\">_local_name</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>\n       <span class=\"n\">info</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n       <span class=\"o\">...</span>\n       <span class=\"n\">handler</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_handler_registry</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">tag_name</span><span class=\"p\">)</span>\n       <span class=\"k\">if</span> <span class=\"n\">handler</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n           <span class=\"n\">info</span> <span class=\"o\">=</span> <span class=\"n\">handler</span><span class=\"p\">(</span><span class=\"n\">info</span><span class=\"p\">)</span>\n       <span class=\"o\">...</span>\n       <span class=\"k\">return</span> <span class=\"n\">info</span>\n</pre></div>\n\n\n<p>This doesn\u2019t cause any duplication or type inconsistency, but it does mean that not all XML is processed the same way, and that means that ergonomic choices have to be explicitly specified, either by us or the user. </p>", "type": "rendered"}, "created_on": "2019-01-02T13:05:47.770690+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2019-01-02T13:05:47.889019+00:00", "type": "pullrequest_comment", "id": 86869104}