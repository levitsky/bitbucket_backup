{"pagelen": 50, "values": [{"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ab67e0d4772f", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/ab67e0d4772f"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/ab67e0d4772f"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "MERGED", "author": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "date": "2016-05-05T14:16:02.176487+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/18105564.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-18105564"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "I had thought that the id_cache code path was in mzIdentML only. Looks good to me.", "markup": "markdown", "html": "<p>I had thought that the id_cache code path was in mzIdentML only. Looks good to me.</p>", "type": "rendered"}, "created_on": "2016-05-04T15:44:50.313076+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-05-04T15:44:50.506880+00:00", "type": "pullrequest_comment", "id": 18105564}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/18103779.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-18103779"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "A cursory look at the memory occupied by the Python process suggests that the memory savings are indeed more significant.\n\nI guess one thing we could add is to suppress building the old ID cache in the IndexedXML constructor, since it is not going to be used by the overridden `get_by_id`.\nI did that in the latest commit. If everything looks OK to you, I am going to accept the PR. Thank you very much for this contribution.", "markup": "markdown", "html": "<p>A cursory look at the memory occupied by the Python process suggests that the memory savings are indeed more significant.</p>\n<p>I guess one thing we could add is to suppress building the old ID cache in the IndexedXML constructor, since it is not going to be used by the overridden <code>get_by_id</code>.\nI did that in the latest commit. If everything looks OK to you, I am going to accept the PR. Thank you very much for this contribution.</p>", "type": "rendered"}, "created_on": "2016-05-04T15:15:45.733881+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-05-04T15:15:45.750498+00:00", "type": "pullrequest_comment", "id": 18103779}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ab67e0d4772f", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/ab67e0d4772f"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/ab67e0d4772f"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "date": "2016-05-04T15:14:07.289905+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17975694.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17975694"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "I saw you did the inheritance hierarchy restructuring yourself, so I did more research into why my tests with `asizeof` showed such poor savings. As I guessed, `asizeof` can't see through pointers, which means it can't take into account the size of the `lxml.etree._Element`'s `xmlNode*` member.\n\n```python\nx = etree.fromstring(\"<tag id='spam'>Content</tag>\")\nasizeof.asizeof(x)\n# 64\n# Access some stored data\nasizeof.asizeof(x.text)\n# 40\nasizeof.asizeof(x.attrib)\n# 48\n\n# For reference\nasizeof.asizeof([])\n# 64\n```\n\nFor that reason, I think its safe to assume that short of some undocumented magic happening somewhere, storing a bunch of short strings and numbers will amount to much less memory used compared to complex C structs.\n\nI don't have anything else to add to this pull request unless you think something is missing. ", "markup": "markdown", "html": "<p>I saw you did the inheritance hierarchy restructuring yourself, so I did more research into why my tests with <code>asizeof</code> showed such poor savings. As I guessed, <code>asizeof</code> can't see through pointers, which means it can't take into account the size of the <code>lxml.etree._Element</code>'s <code>xmlNode*</code> member.</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">etree</span><span class=\"o\">.</span><span class=\"n\">fromstring</span><span class=\"p\">(</span><span class=\"s2\">&quot;&lt;tag id=&#39;spam&#39;&gt;Content&lt;/tag&gt;&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">asizeof</span><span class=\"o\">.</span><span class=\"n\">asizeof</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"c1\"># 64</span>\n<span class=\"c1\"># Access some stored data</span>\n<span class=\"n\">asizeof</span><span class=\"o\">.</span><span class=\"n\">asizeof</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"c1\"># 40</span>\n<span class=\"n\">asizeof</span><span class=\"o\">.</span><span class=\"n\">asizeof</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">)</span>\n<span class=\"c1\"># 48</span>\n\n<span class=\"c1\"># For reference</span>\n<span class=\"n\">asizeof</span><span class=\"o\">.</span><span class=\"n\">asizeof</span><span class=\"p\">([])</span>\n<span class=\"c1\"># 64</span>\n</pre></div>\n\n\n<p>For that reason, I think its safe to assume that short of some undocumented magic happening somewhere, storing a bunch of short strings and numbers will amount to much less memory used compared to complex C structs.</p>\n<p>I don't have anything else to add to this pull request unless you think something is missing. </p>", "type": "rendered"}, "created_on": "2016-05-01T23:54:51.265874+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-05-01T23:54:51.341680+00:00", "type": "pullrequest_comment", "id": 17975694}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "63de26ec057a", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/63de26ec057a"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/63de26ec057a"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "date": "2016-04-29T11:01:21.029257+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17758762.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17758762"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Under the current implementation, you're right, that would be doable, and ultimately more compact that playing games with hidden classes. I'm away until Thursday, at which point I'll do those rewrites. ", "markup": "markdown", "html": "<p>Under the current implementation, you're right, that would be doable, and ultimately more compact that playing games with hidden classes. I'm away until Thursday, at which point I'll do those rewrites. </p>", "type": "rendered"}, "created_on": "2016-04-26T11:19:35.436107+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-26T11:19:35.718483+00:00", "type": "pullrequest_comment", "id": 17758762}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17706819.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17706819"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Do you mean that we just reassign the names?\nIn that case we can't get rid of the IndexedXML name, because it is used in `super` calls. \nBut, since XML is not expected to be used by end users and is backwards compatible (even more so if we do ``use_index = kwargs.get(\"use_index\", False)``), we can also just make `MzML` and others inherit directly from IndexedXML. What do you think?", "markup": "markdown", "html": "<p>Do you mean that we just reassign the names?\nIn that case we can't get rid of the IndexedXML name, because it is used in <code>super</code> calls. \nBut, since XML is not expected to be used by end users and is backwards compatible (even more so if we do <code>use_index = kwargs.get(\"use_index\", False)</code>), we can also just make <code>MzML</code> and others inherit directly from IndexedXML. What do you think?</p>", "type": "rendered"}, "created_on": "2016-04-25T14:16:19.333642+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-25T20:59:44.502541+00:00", "type": "pullrequest_comment", "id": 17706819}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17703936.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17703936"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "If we choose to do option 1, after we define the Indexed derived class, we just replace the name of the base class with the Indexed class, and it seamlessly gets used in `read`. We can save the base class in a _name for testing purposes and for more internal inheritance schemes.", "markup": "markdown", "html": "<p>If we choose to do option 1, after we define the Indexed derived class, we just replace the name of the base class with the Indexed class, and it seamlessly gets used in <code>read</code>. We can save the base class in a _name for testing purposes and for more internal inheritance schemes.</p>", "type": "rendered"}, "created_on": "2016-04-25T13:39:23.944356+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-25T13:39:24.028082+00:00", "type": "pullrequest_comment", "id": 17703936}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17703540.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17703540"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "If 1 is simple enough, I think it's preferable. On the other hand, 2 is kind of already the case, because we have `read()` and it's not going away. With two different indexed classes in `mzml.py`, I guess we'll have to use some kwargs in `mzml.read` anyway.\nI think I'd rather keep the original implementation, mostly because it's \"cleaner\" (as in, doesn't parse XML with regex).\n\nI see that you have already added the `use_index` flag. Does that mean we only have to copy the methods over to `XML` and we are done?", "markup": "markdown", "html": "<p>If 1 is simple enough, I think it's preferable. On the other hand, 2 is kind of already the case, because we have <code>read()</code> and it's not going away. With two different indexed classes in <code>mzml.py</code>, I guess we'll have to use some kwargs in <code>mzml.read</code> anyway.\nI think I'd rather keep the original implementation, mostly because it's \"cleaner\" (as in, doesn't parse XML with regex).</p>\n<p>I see that you have already added the <code>use_index</code> flag. Does that mean we only have to copy the methods over to <code>XML</code> and we are done?</p>", "type": "rendered"}, "created_on": "2016-04-25T13:33:29.188330+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-25T13:33:29.190741+00:00", "type": "pullrequest_comment", "id": 17703540}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "36238f0b5da4", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/36238f0b5da4"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/36238f0b5da4"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "date": "2016-04-25T13:25:55.651341+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "972ee31ee3ea", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/972ee31ee3ea"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/972ee31ee3ea"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-25T11:54:44.283619+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "8b49c7bebca4", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/8b49c7bebca4"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/8b49c7bebca4"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-25T11:53:42.611196+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "6843d4178519", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/6843d4178519"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/6843d4178519"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-24T21:12:46.183892+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17660303.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17660303"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "To unify the API, we have a few options. \n\n1. Simply replace the `XML` class with the `IndexedXML` class and add a switch to turn on or off the index building to avoid space consumption when its not desirable. `Indexed*` are backwards-compatible with not.\n2. Use a factory function. This is not backwards compatible, and involves making code a little harder to interpret since it no longer is clear you're constructing a new object.\n3. Use a metaclass to make 2 look like 1: A metaclass lets you redefine the behavior of a class's `__call__` method, which is usually invoked when you're instantiating a new instance of that class. It receives all the arguments for `__init__` but is allowed to use `return`, letting you control what comes out of that expression. By overriding this behavior, we can detect a keyword argument to turn on or off indexing, and return an appropriate instance accordingly. This might be useful if we want to eventually do 1 but want to inform users that they have some time before that happens while making it possible to write \"future-proof\" code now. Since `Indexed*` are backwards compatible though, I don't see why not just do 1.\n\nAdditionally, though this pull request was originally intended to just make use of pre-existing MzML indexing, it now can index an MzML file in the same scale of time it would take to parse out the index. We can discard that implementation in favor of\n\n```python\nclass IndexedMzML(MzML, xml.IndexedXML):\n    _indexed_tags = {\n        b\"spectrum\", b\"chromatogram\"}\n\n    def __init__(self, *args, **kwargs):\n        super(IndexedMzML, self).__init__(*args, **kwargs)\n\n```", "markup": "markdown", "html": "<p>To unify the API, we have a few options. </p>\n<ol>\n<li>Simply replace the <code>XML</code> class with the <code>IndexedXML</code> class and add a switch to turn on or off the index building to avoid space consumption when its not desirable. <code>Indexed*</code> are backwards-compatible with not.</li>\n<li>Use a factory function. This is not backwards compatible, and involves making code a little harder to interpret since it no longer is clear you're constructing a new object.</li>\n<li>Use a metaclass to make 2 look like 1: A metaclass lets you redefine the behavior of a class's <code>__call__</code> method, which is usually invoked when you're instantiating a new instance of that class. It receives all the arguments for <code>__init__</code> but is allowed to use <code>return</code>, letting you control what comes out of that expression. By overriding this behavior, we can detect a keyword argument to turn on or off indexing, and return an appropriate instance accordingly. This might be useful if we want to eventually do 1 but want to inform users that they have some time before that happens while making it possible to write \"future-proof\" code now. Since <code>Indexed*</code> are backwards compatible though, I don't see why not just do 1.</li>\n</ol>\n<p>Additionally, though this pull request was originally intended to just make use of pre-existing MzML indexing, it now can index an MzML file in the same scale of time it would take to parse out the index. We can discard that implementation in favor of</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">IndexedMzML</span><span class=\"p\">(</span><span class=\"n\">MzML</span><span class=\"p\">,</span> <span class=\"n\">xml</span><span class=\"o\">.</span><span class=\"n\">IndexedXML</span><span class=\"p\">):</span>\n    <span class=\"n\">_indexed_tags</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"sa\">b</span><span class=\"s2\">&quot;spectrum&quot;</span><span class=\"p\">,</span> <span class=\"sa\">b</span><span class=\"s2\">&quot;chromatogram&quot;</span><span class=\"p\">}</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">IndexedMzML</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n</pre></div>", "type": "rendered"}, "created_on": "2016-04-23T22:42:22.295751+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-23T22:42:22.531655+00:00", "type": "pullrequest_comment", "id": 17660303}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17657223.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17657223"}}, "parent": {"id": 17657103, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17657103.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17657103"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "I can try to solve that issue in the index class.\n\nAs for Indexed vs not in XML parser types, just one class makes for the\nbest API. I'll think about the simplest way to do that.", "markup": "markdown", "html": "<p>I can try to solve that issue in the index class.</p>\n<p>As for Indexed vs not in XML parser types, just one class makes for the\nbest API. I'll think about the simplest way to do that.</p>", "type": "rendered"}, "created_on": "2016-04-23T17:40:07.520482+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-23T17:40:07.578165+00:00", "type": "pullrequest_comment", "id": 17657223}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17657103.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17657103"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "This looks very nice, but seems like the string-bytes problems are not gone yet.\nApparently the dict of offsets now has bytes for keys, and when you try to access an element using a string ID, there is a silent `KeyError` inside `get_by_id`, and then the element is found using `iterparse`.\n\nI noticed this because the mzid test currently fails on Python 3, unless you change this:\n\n```\n#!diff\n\ndiff -r 34d9bed90bd3 pyteomics/xml.py\n--- a/pyteomics/xml.py  Sat Apr 23 00:21:31 2016 -0400\n+++ b/pyteomics/xml.py  Sat Apr 23 19:25:02 2016 +0300\n@@ -643,7 +643,7 @@\n             lookup_id_key_mapping = {}\n \n         for name in self.indexed_tags:\n-            lookup_id_key_mapping.setdefault(name, \"id\")\n+            lookup_id_key_mapping.setdefault(name, b\"id\")\n         indices = defaultdict(OrderedDict)\n         g = self._generate_offsets()\n         for offset, offset_type, attrs in g:\n```\n\nSo apparently we want to decode the keys in `_offset_index`. If you are getting tired of this PR, which I can imagine, I think I can change it myself later and just accept it.\n\nOne other thing I'd like your input on: do you think it makes sense to have two separate sets of classes, or would it be better to merge them and introduce another boolean parameter or something like that?", "markup": "markdown", "html": "<p>This looks very nice, but seems like the string-bytes problems are not gone yet.\nApparently the dict of offsets now has bytes for keys, and when you try to access an element using a string ID, there is a silent <code>KeyError</code> inside <code>get_by_id</code>, and then the element is found using <code>iterparse</code>.</p>\n<p>I noticed this because the mzid test currently fails on Python 3, unless you change this:</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r 34d9bed90bd3 pyteomics/xml.py</span>\n<span class=\"gd\">--- a/pyteomics/xml.py  Sat Apr 23 00:21:31 2016 -0400</span>\n<span class=\"gi\">+++ b/pyteomics/xml.py  Sat Apr 23 19:25:02 2016 +0300</span>\n<span class=\"gu\">@@ -643,7 +643,7 @@</span>\n             lookup_id_key_mapping = {}\n\n         for name in self.indexed_tags:\n<span class=\"gd\">-            lookup_id_key_mapping.setdefault(name, &quot;id&quot;)</span>\n<span class=\"gi\">+            lookup_id_key_mapping.setdefault(name, b&quot;id&quot;)</span>\n         indices = defaultdict(OrderedDict)\n         g = self._generate_offsets()\n         for offset, offset_type, attrs in g:\n</pre></div>\n\n\n<p>So apparently we want to decode the keys in <code>_offset_index</code>. If you are getting tired of this PR, which I can imagine, I think I can change it myself later and just accept it.</p>\n<p>One other thing I'd like your input on: do you think it makes sense to have two separate sets of classes, or would it be better to merge them and introduce another boolean parameter or something like that?</p>", "type": "rendered"}, "created_on": "2016-04-23T17:19:18.491783+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-23T17:19:29.183255+00:00", "type": "pullrequest_comment", "id": 17657103}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17649903.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17649903"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "`build_byte_index` and cohort are now part of `ByteCountingXMLScanner`, which is responsible for the same process, such that each of the three methods may be overridden. In the interest of separating concerns, `ByteCountingXMLScanner` is kept separate from `TagSpecificXMLByteIndex` which should only care about working like an index, and the manner in which it extracts the index shouldn't matter to it. The scanner implementation would be pluggable, overriden by `TagSpecificXMLByteIndex._scanner_class`.\n\nThe initialization process for `TagSpecificXMLByteIndex` now uses a file object, rather than being a multipart process.", "markup": "markdown", "html": "<p><code>build_byte_index</code> and cohort are now part of <code>ByteCountingXMLScanner</code>, which is responsible for the same process, such that each of the three methods may be overridden. In the interest of separating concerns, <code>ByteCountingXMLScanner</code> is kept separate from <code>TagSpecificXMLByteIndex</code> which should only care about working like an index, and the manner in which it extracts the index shouldn't matter to it. The scanner implementation would be pluggable, overriden by <code>TagSpecificXMLByteIndex._scanner_class</code>.</p>\n<p>The initialization process for <code>TagSpecificXMLByteIndex</code> now uses a file object, rather than being a multipart process.</p>", "type": "rendered"}, "created_on": "2016-04-23T04:27:21.247949+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-23T04:27:21.311222+00:00", "type": "pullrequest_comment", "id": 17649903}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "34d9bed90bd3", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/34d9bed90bd3"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/34d9bed90bd3"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-23T04:21:49.660664+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17626312.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17626312"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Error handling for building mzML byte index from the provided offsets when the XML is malformed is handled in `mzml._iterparse_index_list`.  Something missing from the offset index is handled in `IndexedXML.get_by_id`, which is common to all `IndexedXML` subclasses.\n\n`IndexedXML.get_by_id` first tries to find a byte offset for the given id, looking it up in `._offset_index`. It then seeks the file point to that byte offset and then starts iterparsing from that point with `_find_by_id_no_reset` which is just an iterparse method. If the id isn't found in the index (KeyError), or if there is an XML parsing error (LxmlError), then it attempts to parse from the start of the file using `_find_by_id_reset`, which is just a decorated `@_keepstate` version of `_find_by_id_no_reset`. I found calling `super().get_by_id` was not resetting the file pointer through the decorator on `XML.get_by_id` so I redid it in `IndexedXML`.\n\nIt's entirely possible `pympler` isn't getting the right size for a C struct since `sizeof` on a pointer to a C struct will just be `sizeof(size_t)` or 8 bytes on my machine, roughly the same size as the byte offset. The items in all the caches are the same. I intentionally cached every tag type that were used. If I cache only the biggest cases like `PeptideEvidence` and `SpectrumIdentificationItem`, the size savings is closer 60% but there is a cost in speed which may depend upon which tag you want to iterate over. For `ProteinDetectionHypothesis`, it was just over 15% slower.\n\nYes, I made the mistake of omitting the `b` prefix on those in `IndexedMzIdentML._indexed_tags`, which I'm using for the default set of tags to cache for derived classes. Previously, you'd have needed to subclass the type in order to change what was indexed. I've changed the `IndexedXML` to take an optional keyword argument `indexed_tags` to take the names of tags to cache, so users can configure it on a per-instance basis. \n\nI added a function to ensure that the indexed tag names are converted into bytes:\n\n```python\ndef ensure_bytes(strings):\n    if isinstance(strings, (basestring)):\n        strings = [strings]\n    results = []\n    for string in strings:\n        try:\n            results.append(string.encode(\"utf-8\"))\n        except:\n            if isinstance(string, bytes):\n                results.append(string)\n            else:\n                warnings.warn(\"%r could not be decoded\" % string)\n    return results\n```\n\nwhich will be called on `IndexedXML.__init__`\n\nI may be writing too much C recently. I'll look at reimplementing those functions as an object.\n\n\n", "markup": "markdown", "html": "<p>Error handling for building mzML byte index from the provided offsets when the XML is malformed is handled in <code>mzml._iterparse_index_list</code>.  Something missing from the offset index is handled in <code>IndexedXML.get_by_id</code>, which is common to all <code>IndexedXML</code> subclasses.</p>\n<p><code>IndexedXML.get_by_id</code> first tries to find a byte offset for the given id, looking it up in <code>._offset_index</code>. It then seeks the file point to that byte offset and then starts iterparsing from that point with <code>_find_by_id_no_reset</code> which is just an iterparse method. If the id isn't found in the index (KeyError), or if there is an XML parsing error (LxmlError), then it attempts to parse from the start of the file using <code>_find_by_id_reset</code>, which is just a decorated <code>@_keepstate</code> version of <code>_find_by_id_no_reset</code>. I found calling <code>super().get_by_id</code> was not resetting the file pointer through the decorator on <code>XML.get_by_id</code> so I redid it in <code>IndexedXML</code>.</p>\n<p>It's entirely possible <code>pympler</code> isn't getting the right size for a C struct since <code>sizeof</code> on a pointer to a C struct will just be <code>sizeof(size_t)</code> or 8 bytes on my machine, roughly the same size as the byte offset. The items in all the caches are the same. I intentionally cached every tag type that were used. If I cache only the biggest cases like <code>PeptideEvidence</code> and <code>SpectrumIdentificationItem</code>, the size savings is closer 60% but there is a cost in speed which may depend upon which tag you want to iterate over. For <code>ProteinDetectionHypothesis</code>, it was just over 15% slower.</p>\n<p>Yes, I made the mistake of omitting the <code>b</code> prefix on those in <code>IndexedMzIdentML._indexed_tags</code>, which I'm using for the default set of tags to cache for derived classes. Previously, you'd have needed to subclass the type in order to change what was indexed. I've changed the <code>IndexedXML</code> to take an optional keyword argument <code>indexed_tags</code> to take the names of tags to cache, so users can configure it on a per-instance basis. </p>\n<p>I added a function to ensure that the indexed tag names are converted into bytes:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">ensure_bytes</span><span class=\"p\">(</span><span class=\"n\">strings</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">strings</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nb\">basestring</span><span class=\"p\">)):</span>\n        <span class=\"n\">strings</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">strings</span><span class=\"p\">]</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">string</span> <span class=\"ow\">in</span> <span class=\"n\">strings</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">results</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s2\">&quot;utf-8&quot;</span><span class=\"p\">))</span>\n        <span class=\"k\">except</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">):</span>\n                <span class=\"n\">results</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">)</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">warnings</span><span class=\"o\">.</span><span class=\"n\">warn</span><span class=\"p\">(</span><span class=\"s2\">&quot;</span><span class=\"si\">%r</span><span class=\"s2\"> could not be decoded&quot;</span> <span class=\"o\">%</span> <span class=\"n\">string</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">results</span>\n</pre></div>\n\n\n<p>which will be called on <code>IndexedXML.__init__</code></p>\n<p>I may be writing too much C recently. I'll look at reimplementing those functions as an object.</p>", "type": "rendered"}, "created_on": "2016-04-22T15:01:57.559530+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-22T15:01:57.708121+00:00", "type": "pullrequest_comment", "id": 17626312}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ef835df89b7b", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/ef835df89b7b"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/ef835df89b7b"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-22T14:24:27.280216+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "3945321393df", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/3945321393df"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/3945321393df"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-22T14:08:40.600258+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17620122.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17620122"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "I like this implementation a lot. Questions:\n\n* error handling machinery for mzML is not in place yet, is that right or am I missing something?\n\n* I don't quite get the idea behind `_find_by_id_no_reset` vs `_find_by_id_reset`. Why do we need them and why is one in the `try` and the other in the `except`?\n\n* 30% is nice, but I kind of expected more. Are lxml elements really so compact or is it an unfair comparison? Is the number of elements the same in the two caches?\n\n* The test for `mzid` fails because of yet another bytes-string issue:\n\n\n```\n#!python\n\n  File \".../pyteomics/xml.py\", line 604, in generate_offsets\n    packed = b\"|\".join(names)\nTypeError: sequence item 0: expected a bytes-like object, str found\n```\nApparently this is because the indexed tags are strings. I don't think they need to be bytes, I'd rather have them explicitly encoded to ASCII somewhere in `__init__` or elsewhere.\n\nCompletely unimportant: do you think it makes sense to have `build_byte_index`, `generate_offsets` and `_index_finding_chunker` as free functions and not methods of `TagSpecificXMLByteIndex`, for example?\nAlso, don't we want to initialize `TagSpecificXMLByteIndex` with a file object, like we do with `XML` and such?", "markup": "markdown", "html": "<p>I like this implementation a lot. Questions:</p>\n<ul>\n<li>\n<p>error handling machinery for mzML is not in place yet, is that right or am I missing something?</p>\n</li>\n<li>\n<p>I don't quite get the idea behind <code>_find_by_id_no_reset</code> vs <code>_find_by_id_reset</code>. Why do we need them and why is one in the <code>try</code> and the other in the <code>except</code>?</p>\n</li>\n<li>\n<p>30% is nice, but I kind of expected more. Are lxml elements really so compact or is it an unfair comparison? Is the number of elements the same in the two caches?</p>\n</li>\n<li>\n<p>The test for <code>mzid</code> fails because of yet another bytes-string issue:</p>\n</li>\n</ul>\n<div class=\"codehilite language-python\"><pre><span></span>  <span class=\"n\">File</span> <span class=\"s2\">&quot;.../pyteomics/xml.py&quot;</span><span class=\"p\">,</span> <span class=\"n\">line</span> <span class=\"mi\">604</span><span class=\"p\">,</span> <span class=\"ow\">in</span> <span class=\"n\">generate_offsets</span>\n    <span class=\"n\">packed</span> <span class=\"o\">=</span> <span class=\"sa\">b</span><span class=\"s2\">&quot;|&quot;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">names</span><span class=\"p\">)</span>\n<span class=\"ne\">TypeError</span><span class=\"p\">:</span> <span class=\"n\">sequence</span> <span class=\"n\">item</span> <span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"n\">expected</span> <span class=\"n\">a</span> <span class=\"nb\">bytes</span><span class=\"o\">-</span><span class=\"n\">like</span> <span class=\"nb\">object</span><span class=\"p\">,</span> <span class=\"nb\">str</span> <span class=\"n\">found</span>\n</pre></div>\n\n\n<p>Apparently this is because the indexed tags are strings. I don't think they need to be bytes, I'd rather have them explicitly encoded to ASCII somewhere in <code>__init__</code> or elsewhere.</p>\n<p>Completely unimportant: do you think it makes sense to have <code>build_byte_index</code>, <code>generate_offsets</code> and <code>_index_finding_chunker</code> as free functions and not methods of <code>TagSpecificXMLByteIndex</code>, for example?\nAlso, don't we want to initialize <code>TagSpecificXMLByteIndex</code> with a file object, like we do with <code>XML</code> and such?</p>", "type": "rendered"}, "created_on": "2016-04-22T13:26:25.938017+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-22T13:26:25.940439+00:00", "type": "pullrequest_comment", "id": 17620122}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17522754.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17522754"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "I've revised the XML parsing scheme to use a layered approach where the lowest layer is responsible for viewing the input binary file as blocks of data that may contain tokens that delimit XML tags, producing chunks of data exactly one XML tag at a time regardless of white space. It should address your concerns about assumptions made about the format of the input. I believe I caught the problem points between `bytes` and `str` in Python 3, ensuring that the input patterns are bytes though I'm not certain of whether I should coerce them from strings or if the end user is aware of this. I read Armin Ronacher's diatribe on the divide and I may be assuming the incompatibility is more extreme than it is. \n\nI moved a lot of the logic from the original `IndexedMzML` implementation into a generic `IndexedXML` class, and let that deal with the common problem of constructing the byte offset index and doing the look ups correctly. This made the implementation of `IndexedMzIdentML` straightforwards. Running side by side on a file I usually parse as part of my processing pipeline, I ran the following benchmark:\n\n```\nreader = mzid.MzIdentML(mzid_path, retrieve_refs=True, iterative=False)\ncached_reader = mzid.MzIdentML(mzid_path, retrieve_refs=True, iterative=False, build_id_cache=True)\nindexed_reader = mzid.IndexedMzIdentML(mzid_path, retrieve_refs=True, iterative=False)\n\n%timeit len(list(reader.iterfind(\"ProteinDetectionHypothesis\", retrieve_refs=True, recursive=False, iterative=True)))\n# 1 loops, best of 3: 3.41 s per loop\n%timeit len(list(cached_reader.iterfind(\"ProteinDetectionHypothesis\", retrieve_refs=True, recursive=False, iterative=True)))\n# 10 loops, best of 3: 164 ms per loop\n%timeit len(list(indexed_reader.iterfind(\"ProteinDetectionHypothesis\", retrieve_refs=True, recursive=False, iterative=True)))\n# 10 loops, best of 3: 168 ms per loop\n```\nThis shows that the Indexed version is just about as fast as the version that loads all of the relevant XML elements into memory for the duration of the parse. Since both the byte offset index and that element cache eat memory though, I ran a space comparison with `pympler`. \n\n```\nasizeof.asizeof(reader)\n# 14640\nasizeof.asizeof(indexed_reader)\n# 5250328\nasizeof.asizeof(cached_reader)\n# 7599712\n```\n\nSo a savings of just a little over 30% in space. Its possible to get more granular control in the time-space tradeoff by changing which element types you include in the index, which may be worthwhile if I start dealing with more complex data sets on a more restricted machine.\n\nThese implementations appear to pass all existing unit tests. ", "markup": "markdown", "html": "<p>I've revised the XML parsing scheme to use a layered approach where the lowest layer is responsible for viewing the input binary file as blocks of data that may contain tokens that delimit XML tags, producing chunks of data exactly one XML tag at a time regardless of white space. It should address your concerns about assumptions made about the format of the input. I believe I caught the problem points between <code>bytes</code> and <code>str</code> in Python 3, ensuring that the input patterns are bytes though I'm not certain of whether I should coerce them from strings or if the end user is aware of this. I read Armin Ronacher's diatribe on the divide and I may be assuming the incompatibility is more extreme than it is. </p>\n<p>I moved a lot of the logic from the original <code>IndexedMzML</code> implementation into a generic <code>IndexedXML</code> class, and let that deal with the common problem of constructing the byte offset index and doing the look ups correctly. This made the implementation of <code>IndexedMzIdentML</code> straightforwards. Running side by side on a file I usually parse as part of my processing pipeline, I ran the following benchmark:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">mzid</span><span class=\"p\">.</span><span class=\"n\">MzIdentML</span><span class=\"p\">(</span><span class=\"n\">mzid_path</span><span class=\"p\">,</span> <span class=\"n\">retrieve_refs</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">,</span> <span class=\"n\">iterative</span><span class=\"o\">=</span><span class=\"n\">False</span><span class=\"p\">)</span>\n<span class=\"n\">cached_reader</span> <span class=\"o\">=</span> <span class=\"n\">mzid</span><span class=\"p\">.</span><span class=\"n\">MzIdentML</span><span class=\"p\">(</span><span class=\"n\">mzid_path</span><span class=\"p\">,</span> <span class=\"n\">retrieve_refs</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">,</span> <span class=\"n\">iterative</span><span class=\"o\">=</span><span class=\"n\">False</span><span class=\"p\">,</span> <span class=\"n\">build_id_cache</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">)</span>\n<span class=\"n\">indexed_reader</span> <span class=\"o\">=</span> <span class=\"n\">mzid</span><span class=\"p\">.</span><span class=\"n\">IndexedMzIdentML</span><span class=\"p\">(</span><span class=\"n\">mzid_path</span><span class=\"p\">,</span> <span class=\"n\">retrieve_refs</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">,</span> <span class=\"n\">iterative</span><span class=\"o\">=</span><span class=\"n\">False</span><span class=\"p\">)</span>\n\n<span class=\"nf\">%timeit</span> <span class=\"n\">len</span><span class=\"p\">(</span><span class=\"n\">list</span><span class=\"p\">(</span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">iterfind</span><span class=\"p\">(</span><span class=\"s\">&quot;ProteinDetectionHypothesis&quot;</span><span class=\"p\">,</span> <span class=\"n\">retrieve_refs</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">,</span> <span class=\"n\">recursive</span><span class=\"o\">=</span><span class=\"n\">False</span><span class=\"p\">,</span> <span class=\"n\">iterative</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">)))</span>\n<span class=\"cp\"># 1 loops, best of 3: 3.41 s per loop</span>\n<span class=\"nf\">%timeit</span> <span class=\"n\">len</span><span class=\"p\">(</span><span class=\"n\">list</span><span class=\"p\">(</span><span class=\"n\">cached_reader</span><span class=\"p\">.</span><span class=\"n\">iterfind</span><span class=\"p\">(</span><span class=\"s\">&quot;ProteinDetectionHypothesis&quot;</span><span class=\"p\">,</span> <span class=\"n\">retrieve_refs</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">,</span> <span class=\"n\">recursive</span><span class=\"o\">=</span><span class=\"n\">False</span><span class=\"p\">,</span> <span class=\"n\">iterative</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">)))</span>\n<span class=\"cp\"># 10 loops, best of 3: 164 ms per loop</span>\n<span class=\"nf\">%timeit</span> <span class=\"n\">len</span><span class=\"p\">(</span><span class=\"n\">list</span><span class=\"p\">(</span><span class=\"n\">indexed_reader</span><span class=\"p\">.</span><span class=\"n\">iterfind</span><span class=\"p\">(</span><span class=\"s\">&quot;ProteinDetectionHypothesis&quot;</span><span class=\"p\">,</span> <span class=\"n\">retrieve_refs</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">,</span> <span class=\"n\">recursive</span><span class=\"o\">=</span><span class=\"n\">False</span><span class=\"p\">,</span> <span class=\"n\">iterative</span><span class=\"o\">=</span><span class=\"n\">True</span><span class=\"p\">)))</span>\n<span class=\"cp\"># 10 loops, best of 3: 168 ms per loop</span>\n</pre></div>\n\n\n<p>This shows that the Indexed version is just about as fast as the version that loads all of the relevant XML elements into memory for the duration of the parse. Since both the byte offset index and that element cache eat memory though, I ran a space comparison with <code>pympler</code>. </p>\n<div class=\"codehilite\"><pre><span></span>asizeof.asizeof(reader)\n# 14640\nasizeof.asizeof(indexed_reader)\n# 5250328\nasizeof.asizeof(cached_reader)\n# 7599712\n</pre></div>\n\n\n<p>So a savings of just a little over 30% in space. Its possible to get more granular control in the time-space tradeoff by changing which element types you include in the index, which may be worthwhile if I start dealing with more complex data sets on a more restricted machine.</p>\n<p>These implementations appear to pass all existing unit tests. </p>", "type": "rendered"}, "created_on": "2016-04-20T19:21:32.328207+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-20T19:21:32.565316+00:00", "type": "pullrequest_comment", "id": 17522754}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "7e249694c92f", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/7e249694c92f"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/7e249694c92f"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-20T19:21:04.418732+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ff0f6d3fcda2", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/ff0f6d3fcda2"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/ff0f6d3fcda2"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-20T18:55:16.733558+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17455267.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17455267"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Thanks, I pushed the fixes I mentioned.\n\nProteowizard may not be the only source of mzML files, but more importantly, we are trying to write something for all XML files, so it's better not to make any assumptions.\nYes, my understanding is also that Python's file objects are buffered.", "markup": "markdown", "html": "<p>Thanks, I pushed the fixes I mentioned.</p>\n<p>Proteowizard may not be the only source of mzML files, but more importantly, we are trying to write something for all XML files, so it's better not to make any assumptions.\nYes, my understanding is also that Python's file objects are buffered.</p>", "type": "rendered"}, "created_on": "2016-04-19T16:06:07.666549+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-19T16:06:07.668203+00:00", "type": "pullrequest_comment", "id": 17455267}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "462ef58671ac", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/462ef58671ac"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/462ef58671ac"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "date": "2016-04-17T20:25:30.507955+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17351963.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17351963"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "I've given you write permission.\n\nYes, I routinely make these mistakes with strings for Python3 sources since I still work primarily on 2.7. Over the summer, when there aren't any pressing deadlines, I'll update my projects to work on Python 3.5, so this should come to an end soon.\n\nI've never seen Proteowizard generate an XML file with multiple tags on the same line, but it's not impossible. I'll see how well behaved the code is after changing to `findall`.\n\nI tried the following approach to byte counting incrementally in pure Python since the XML parser approach failed.\n\n```python\nclass BufferedByteStreamReader(object):\n    attr_pattern = re.compile(r\"(\\S+)=\\\"(\\S+)\\\"\")\n\n    def __init__(self, stream, target_tag):\n        self.stream = stream\n        self.current_offset = 0\n        self.target_tag = target_tag\n        self.target_buffer = \"<\" + target_tag + ' '\n        self.buffer_length = len(self.target_buffer)\n        self.buffer = deque()\n\n    def parse(self):\n        i = 0\n        self.current_offset = self.buffer_length\n        self.buffer.extend(self.stream.read(self.buffer_length))\n        joiner = ''.join\n        while True:\n            i += 1\n            if (self.buffer[0] == self.target_buffer[0]) and\\\n               (self.buffer[1] == self.target_buffer[1]) and\\\n               (self.buffer[2] == self.target_buffer[2]):\n                if joiner(self.buffer) == self.target_buffer:\n                    offset = self.current_offset - self.buffer_length\n                    rest = self.complete_tag()\n                    tag = joiner(list(self.buffer) + rest)\n                    attrs = self.extract_attributes(tag)\n                    self.buffer = deque(self.stream.read(self.buffer_length))\n                    self.current_offset += self.buffer_length\n                    yield offset, attrs\n\n            self.buffer.popleft()\n            self.buffer.append(self.stream.read(1))\n            self.current_offset += 1\n\n    def complete_tag(self):\n        charbuffer = []\n        parse = True\n        while parse:\n            char = self.stream.read(1)\n            if char == \">\":\n                parse = False\n            self.current_offset += 1\n            charbuffer.append(char)\n        return charbuffer\n\n    def extract_attributes(self, tag):\n        return dict(self.attr_pattern.findall(tag))\n```\n\nUnfortunately, it really is too slow to be practical for mzML. It could still work for smaller files like mzIdentML, and would be able to handle more pathological cases than the line-based reader. That said, I assumed that the `file` object was really buffered internally as well, which I think is the case from reading the standard library's `io` documentation. Otherwise, all of the calls I made to `file.read` with small byte counts are going to be massively wasteful.", "markup": "markdown", "html": "<p>I've given you write permission.</p>\n<p>Yes, I routinely make these mistakes with strings for Python3 sources since I still work primarily on 2.7. Over the summer, when there aren't any pressing deadlines, I'll update my projects to work on Python 3.5, so this should come to an end soon.</p>\n<p>I've never seen Proteowizard generate an XML file with multiple tags on the same line, but it's not impossible. I'll see how well behaved the code is after changing to <code>findall</code>.</p>\n<p>I tried the following approach to byte counting incrementally in pure Python since the XML parser approach failed.</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">BufferedByteStreamReader</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"n\">attr_pattern</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;(\\S+)=</span><span class=\"se\">\\&quot;</span><span class=\"s2\">(\\S+)</span><span class=\"se\">\\&quot;</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">stream</span><span class=\"p\">,</span> <span class=\"n\">target_tag</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span> <span class=\"o\">=</span> <span class=\"n\">stream</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_tag</span> <span class=\"o\">=</span> <span class=\"n\">target_tag</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;&lt;&quot;</span> <span class=\"o\">+</span> <span class=\"n\">target_tag</span> <span class=\"o\">+</span> <span class=\"s1\">&#39; &#39;</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">deque</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">parse</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span><span class=\"p\">))</span>\n        <span class=\"n\">joiner</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span>\n        <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"ow\">and</span>\\\n               <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span> <span class=\"ow\">and</span>\\\n               <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]):</span>\n                <span class=\"k\">if</span> <span class=\"n\">joiner</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">:</span>\n                    <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">-</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span>\n                    <span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">complete_tag</span><span class=\"p\">()</span>\n                    <span class=\"n\">tag</span> <span class=\"o\">=</span> <span class=\"n\">joiner</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">rest</span><span class=\"p\">)</span>\n                    <span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">extract_attributes</span><span class=\"p\">(</span><span class=\"n\">tag</span><span class=\"p\">)</span>\n                    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">deque</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span><span class=\"p\">))</span>\n                    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span>\n                    <span class=\"k\">yield</span> <span class=\"n\">offset</span><span class=\"p\">,</span> <span class=\"n\">attrs</span>\n\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">popleft</span><span class=\"p\">()</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">complete_tag</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">charbuffer</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">parse</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>\n        <span class=\"k\">while</span> <span class=\"n\">parse</span><span class=\"p\">:</span>\n            <span class=\"n\">char</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">char</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;&gt;&quot;</span><span class=\"p\">:</span>\n                <span class=\"n\">parse</span> <span class=\"o\">=</span> <span class=\"bp\">False</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">charbuffer</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">char</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">charbuffer</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">extract_attributes</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">tag</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">attr_pattern</span><span class=\"o\">.</span><span class=\"n\">findall</span><span class=\"p\">(</span><span class=\"n\">tag</span><span class=\"p\">))</span>\n</pre></div>\n\n\n<p>Unfortunately, it really is too slow to be practical for mzML. It could still work for smaller files like mzIdentML, and would be able to handle more pathological cases than the line-based reader. That said, I assumed that the <code>file</code> object was really buffered internally as well, which I think is the case from reading the standard library's <code>io</code> documentation. Otherwise, all of the calls I made to <code>file.read</code> with small byte counts are going to be massively wasteful.</p>", "type": "rendered"}, "created_on": "2016-04-17T18:53:25.781244+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-17T18:53:25.916000+00:00", "type": "pullrequest_comment", "id": 17351963}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17351755.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17351755"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Sorry for the delay.\n\nI like the mzML part even better now that `re` is only used to find the index offset. But if I understand correctly, it will only work for valid indices.\nThe `generate_offsets` and `build_byte_index` of course raise more doubts, but in general it looks like they are the only way to go if we want to get this functionality for broken files, so we need to incorporate it somewhere in a chain of try's and except's.\n\nThe code you have in there right now is:\n\n```\n#!python\npattern = re.compile(r\"^[ ]*<(%s)\\s\" % packed)\nattrs = re.compile(r\"(\\S+)=\\\"(\\S+)\\\"\")\nfor line in file_obj:\n    match = pattern.match(line)\n```\nMy main concerns with the current patterns are:\n\n* `[ ]*` should be probably changed to `\\s*` and `\\\"(\\S+)\\\"` (for attribute values) to something like `\\\"([^\"]+)\\\"`\n* single vs double quotes. Would it be reasonable to ignore this?\n* one tag per line assumption, which was mentioned before. Can we do something like \n```\n#!python\n\npattern = re.compile(r\"\\s*<(%s)\\s((\\w)=\\\"([^\"])\\\")*\" % packed) # not tested\nfor line in file_obj:\n    for match in re.findall(pattern, line):\n        ...\n```\n\nP.S. I don't have the write permission to your fork at the moment. Also, the current code doesn't pass the test. Here are a couple of fixes:\n\n\n```\n#!diff\n\ndiff -r 8ce966e9de27 pyteomics/mzml.py\n--- a/pyteomics/mzml.py Tue Apr 12 12:46:22 2016 -0400\n+++ b/pyteomics/mzml.py Sun Apr 17 21:10:19 2016 +0300\n@@ -63,13 +63,10 @@\n import numpy as np\n import zlib\n import base64\n+import re\n from . import xml, auxiliary as aux\n from .xml import etree\n \n@@ -270,7 +267,7 @@\n     \"\"\"\n     file_obj.seek(-1024, 2)\n     text = file_obj.read(1024)\n-    index_offsets = list(map(int, re.findall(r\"<indexListOffset>(\\d+)</indexListOffset>\", text)))\n+    index_offsets = list(map(int, re.findall(br\"<indexListOffset>(\\d+)</indexListOffset>\", text)))\n     return index_offsets\n \n \n@@ -390,7 +387,7 @@\n             elem = self._find_by_id_no_reset(elem_id)\n             data = self._get_info_smart(elem, recursive=True)\n             return data\n-        except KeyError, etree.LxmlError:\n+        except (KeyError, etree.LxmlError):\n             return super(IndexedMzML, self).get_by_id(elem_id)\n \n     def __getitem__(self, elem_id):\n```\n\nThe parentheses in `except` are needed in Python 3, and also in Python 3 the file mode makes more difference, so we can't search for a string in binary file.\nWe probably need to carefully address the fact that XML files are opened in binary mode by default and the matching is done using strings. Maybe just changing everything to byte literals will be enough.\nAlso, in Python 3 we'll need to import `basestring` from `.auxiliary`.", "markup": "markdown", "html": "<p>Sorry for the delay.</p>\n<p>I like the mzML part even better now that <code>re</code> is only used to find the index offset. But if I understand correctly, it will only work for valid indices.\nThe <code>generate_offsets</code> and <code>build_byte_index</code> of course raise more doubts, but in general it looks like they are the only way to go if we want to get this functionality for broken files, so we need to incorporate it somewhere in a chain of try's and except's.</p>\n<p>The code you have in there right now is:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;^[ ]*&lt;(</span><span class=\"si\">%s</span><span class=\"s2\">)\\s&quot;</span> <span class=\"o\">%</span> <span class=\"n\">packed</span><span class=\"p\">)</span>\n<span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;(\\S+)=</span><span class=\"se\">\\&quot;</span><span class=\"s2\">(\\S+)</span><span class=\"se\">\\&quot;</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">file_obj</span><span class=\"p\">:</span>\n    <span class=\"n\">match</span> <span class=\"o\">=</span> <span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>My main concerns with the current patterns are:</p>\n<ul>\n<li><code>[ ]*</code> should be probably changed to <code>\\s*</code> and <code>\\\"(\\S+)\\\"</code> (for attribute values) to something like <code>\\\"([^\"]+)\\\"</code></li>\n<li>single vs double quotes. Would it be reasonable to ignore this?</li>\n<li>one tag per line assumption, which was mentioned before. Can we do something like </li>\n</ul>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;\\s*&lt;(</span><span class=\"si\">%s</span><span class=\"s2\">)\\s((\\w)=</span><span class=\"se\">\\&quot;</span><span class=\"s2\">([^&quot;</span><span class=\"p\">])</span>\\<span class=\"s2\">&quot;)*&quot;</span> <span class=\"o\">%</span> <span class=\"n\">packed</span><span class=\"p\">)</span> <span class=\"c1\"># not tested</span>\n<span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">file_obj</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">match</span> <span class=\"ow\">in</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">findall</span><span class=\"p\">(</span><span class=\"n\">pattern</span><span class=\"p\">,</span> <span class=\"n\">line</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n</pre></div>\n\n\n<p>P.S. I don't have the write permission to your fork at the moment. Also, the current code doesn't pass the test. Here are a couple of fixes:</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r 8ce966e9de27 pyteomics/mzml.py</span>\n<span class=\"gd\">--- a/pyteomics/mzml.py Tue Apr 12 12:46:22 2016 -0400</span>\n<span class=\"gi\">+++ b/pyteomics/mzml.py Sun Apr 17 21:10:19 2016 +0300</span>\n<span class=\"gu\">@@ -63,13 +63,10 @@</span>\n import numpy as np\n import zlib\n import base64\n<span class=\"gi\">+import re</span>\n from . import xml, auxiliary as aux\n from .xml import etree\n\n<span class=\"gu\">@@ -270,7 +267,7 @@</span>\n     &quot;&quot;&quot;\n     file_obj.seek(-1024, 2)\n     text = file_obj.read(1024)\n<span class=\"gd\">-    index_offsets = list(map(int, re.findall(r&quot;&lt;indexListOffset&gt;(\\d+)&lt;/indexListOffset&gt;&quot;, text)))</span>\n<span class=\"gi\">+    index_offsets = list(map(int, re.findall(br&quot;&lt;indexListOffset&gt;(\\d+)&lt;/indexListOffset&gt;&quot;, text)))</span>\n     return index_offsets\n\n\n<span class=\"gu\">@@ -390,7 +387,7 @@</span>\n             elem = self._find_by_id_no_reset(elem_id)\n             data = self._get_info_smart(elem, recursive=True)\n             return data\n<span class=\"gd\">-        except KeyError, etree.LxmlError:</span>\n<span class=\"gi\">+        except (KeyError, etree.LxmlError):</span>\n             return super(IndexedMzML, self).get_by_id(elem_id)\n\n     def __getitem__(self, elem_id):\n</pre></div>\n\n\n<p>The parentheses in <code>except</code> are needed in Python 3, and also in Python 3 the file mode makes more difference, so we can't search for a string in binary file.\nWe probably need to carefully address the fact that XML files are opened in binary mode by default and the matching is done using strings. Maybe just changing everything to byte literals will be enough.\nAlso, in Python 3 we'll need to import <code>basestring</code> from <code>.auxiliary</code>.</p>", "type": "rendered"}, "created_on": "2016-04-17T18:19:08.536697+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-17T18:19:08.539438+00:00", "type": "pullrequest_comment", "id": 17351755}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17145125.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17145125"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "I have added the example file to the main body of the pull request text.", "markup": "markdown", "html": "<p>I have added the example file to the main body of the pull request text.</p>", "type": "rendered"}, "created_on": "2016-04-13T01:09:44.429085+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-13T01:09:44.492273+00:00", "type": "pullrequest_comment", "id": 17145125}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.\r\n\r\nAn example MzML file from the wild a year ago with an invalid index is available compressed at [https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing](https://drive.google.com/file/d/0B6adxGixQdBaZUNDaGdwNDBpMWc/view?usp=sharing) The file is quite large, so it is compressed.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "8ce966e9de27", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/8ce966e9de27"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/8ce966e9de27"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-13T01:08:47.871210+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17124197.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17124197"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Yeah, depending upon line breaks is dicey. What would we be looping over if we used `findall`?\n\nWe could also use a buffered byte stream, but that iteration would be in pure python, which my instincts tell me will be slow, but I should test that.\n\nI'm compressing an example MzML with invalid offsets, but supposedly there can be IndexedMzML files with missing offset indices, or where the offset indices are not where they're supposed to be. My parser should be able to handle those cases with the worst case being that it will parse the last X bytes of the file quickly without building an index, but I do not have an example to test on and I have yet to find a safe way to edit the text of an MzML file since they are so big.\n\nYou should be able to commit to my fork of `pyteomics`. If not, I'll set the permissions so you can.", "markup": "markdown", "html": "<p>Yeah, depending upon line breaks is dicey. What would we be looping over if we used <code>findall</code>?</p>\n<p>We could also use a buffered byte stream, but that iteration would be in pure python, which my instincts tell me will be slow, but I should test that.</p>\n<p>I'm compressing an example MzML with invalid offsets, but supposedly there can be IndexedMzML files with missing offset indices, or where the offset indices are not where they're supposed to be. My parser should be able to handle those cases with the worst case being that it will parse the last X bytes of the file quickly without building an index, but I do not have an example to test on and I have yet to find a safe way to edit the text of an MzML file since they are so big.</p>\n<p>You should be able to commit to my fork of <code>pyteomics</code>. If not, I'll set the permissions so you can.</p>", "type": "rendered"}, "created_on": "2016-04-12T16:51:50.636997+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-12T16:51:50.903385+00:00", "type": "pullrequest_comment", "id": 17124197}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "8ce966e9de27", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/8ce966e9de27"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/8ce966e9de27"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-12T16:46:41.929257+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17122573.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17122573"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "It's a nice idea, but it seems risky to rely on linebreaks after every tag. Can't we tweak the patterns and use `findall` with a loop instead?\nI also have minor nitpicky questions about your implementations, but I guess it's better for me to play with this code and some files myself before asking. To this end, could you provide an example file with corrupted index?\n\nI'm not sure if there's a way to collaborate on a pull request before merging it (add commits, etc.)", "markup": "markdown", "html": "<p>It's a nice idea, but it seems risky to rely on linebreaks after every tag. Can't we tweak the patterns and use <code>findall</code> with a loop instead?\nI also have minor nitpicky questions about your implementations, but I guess it's better for me to play with this code and some files myself before asking. To this end, could you provide an example file with corrupted index?</p>\n<p>I'm not sure if there's a way to collaborate on a pull request before merging it (add commits, etc.)</p>", "type": "rendered"}, "created_on": "2016-04-12T16:18:48.995054+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-12T16:18:49.002816+00:00", "type": "pullrequest_comment", "id": 17122573}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/16861871.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-16861871"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Attempting to build up an index of byte offsets with `lxml` is not possible since it only reports source lines. The standard library's `expat` bindings looked promising, but failed in the end because they use a *signed* `long` to report byte offsets, so it would involve both overflow detection and sign correction in a platform dependent fashion. Attempting to trick either of these libraries into advancing a file pointer did not work as the `file.tell()` call after each yielded tag did not line up with the tag. In the end, iterating over the lines of the file and counting the characters per line, using a regular expression to detect when a tag of interest was found.\n\n```python\ndef generate_offsets(file_obj, names):\n    \"\"\"\n    Iterate over the lines of an XML file where each line contains exactly one tag,\n    tracking the byte count for each line. When a line contains a tag whose name matches\n    a name in `names`, yield the byte offset, the tag type, and it's attributes.\n\n    Parameters\n    ----------\n    file_obj : file\n        File to parse\n    names : str or iterable of str\n        The name or names to yield byte offsets for\n\n    Yields\n    ------\n    offset : int\n        The byte offset of a matched tag's opening line\n    tag_type : str\n        The type of tag matched\n    attr_dict : dict\n        The attributes on the matched tag\n    \"\"\"\n    i = 0\n    if isinstance(names, basestring):\n        names = [names]\n    packed = \"|\".join(names)\n    pattern = re.compile(r\"^[ ]*<(%s)\\s\" % packed)\n    attrs = re.compile(r\"(\\S+)=\\\"(\\S+)\\\"\")\n    for line in file_obj:\n        match = pattern.match(line)\n        if match:\n            yield i, match.group(1), dict(attrs.findall(line))\n        i += len(line)\n```\n\nThis method burned through the file faster than `expat` because it wasn't trying to completely parse every line. It's only downside is that it requires the file to contain new line characters, which are not mandatory for well formed XML. I was able to use these offsets to properly seek each `spectrum` and `chromatogram` tag and it can also be applied to other XML files. If this approach seems okay to you, I'll add it to the `xml` module and mint a new `IndexedXML` class whose `get_by_id` method first checks the id cache, then the byte offset index, and then iterparse.\n", "markup": "markdown", "html": "<p>Attempting to build up an index of byte offsets with <code>lxml</code> is not possible since it only reports source lines. The standard library's <code>expat</code> bindings looked promising, but failed in the end because they use a <em>signed</em> <code>long</code> to report byte offsets, so it would involve both overflow detection and sign correction in a platform dependent fashion. Attempting to trick either of these libraries into advancing a file pointer did not work as the <code>file.tell()</code> call after each yielded tag did not line up with the tag. In the end, iterating over the lines of the file and counting the characters per line, using a regular expression to detect when a tag of interest was found.</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">generate_offsets</span><span class=\"p\">(</span><span class=\"n\">file_obj</span><span class=\"p\">,</span> <span class=\"n\">names</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Iterate over the lines of an XML file where each line contains exactly one tag,</span>\n<span class=\"sd\">    tracking the byte count for each line. When a line contains a tag whose name matches</span>\n<span class=\"sd\">    a name in `names`, yield the byte offset, the tag type, and it&#39;s attributes.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    file_obj : file</span>\n<span class=\"sd\">        File to parse</span>\n<span class=\"sd\">    names : str or iterable of str</span>\n<span class=\"sd\">        The name or names to yield byte offsets for</span>\n\n<span class=\"sd\">    Yields</span>\n<span class=\"sd\">    ------</span>\n<span class=\"sd\">    offset : int</span>\n<span class=\"sd\">        The byte offset of a matched tag&#39;s opening line</span>\n<span class=\"sd\">    tag_type : str</span>\n<span class=\"sd\">        The type of tag matched</span>\n<span class=\"sd\">    attr_dict : dict</span>\n<span class=\"sd\">        The attributes on the matched tag</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">names</span><span class=\"p\">,</span> <span class=\"nb\">basestring</span><span class=\"p\">):</span>\n        <span class=\"n\">names</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">names</span><span class=\"p\">]</span>\n    <span class=\"n\">packed</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;|&quot;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">names</span><span class=\"p\">)</span>\n    <span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;^[ ]*&lt;(</span><span class=\"si\">%s</span><span class=\"s2\">)\\s&quot;</span> <span class=\"o\">%</span> <span class=\"n\">packed</span><span class=\"p\">)</span>\n    <span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;(\\S+)=</span><span class=\"se\">\\&quot;</span><span class=\"s2\">(\\S+)</span><span class=\"se\">\\&quot;</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">file_obj</span><span class=\"p\">:</span>\n        <span class=\"n\">match</span> <span class=\"o\">=</span> <span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">match</span><span class=\"p\">:</span>\n            <span class=\"k\">yield</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">match</span><span class=\"o\">.</span><span class=\"n\">group</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">attrs</span><span class=\"o\">.</span><span class=\"n\">findall</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">))</span>\n        <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>This method burned through the file faster than <code>expat</code> because it wasn't trying to completely parse every line. It's only downside is that it requires the file to contain new line characters, which are not mandatory for well formed XML. I was able to use these offsets to properly seek each <code>spectrum</code> and <code>chromatogram</code> tag and it can also be applied to other XML files. If this approach seems okay to you, I'll add it to the <code>xml</code> module and mint a new <code>IndexedXML</code> class whose <code>get_by_id</code> method first checks the id cache, then the byte offset index, and then iterparse.</p>", "type": "rendered"}, "created_on": "2016-04-06T14:11:16.724217+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-06T14:11:16.863996+00:00", "type": "pullrequest_comment", "id": 16861871}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/16675692.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-16675692"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "There's no urgency, I just got around to working out the idiosyncracies of Mercurial and BitBucket so I could make a pull request.\n\nYou're correct in that `read_from_start` should probably reuse `_keepstate`. I had originally been writing this as a little one-off script and wasn't thinking about those utilities. `_keepstate` as it is right now isn't appropriate for a function which needs to reset a file-like object (or a path of a file) multiple times internally, as is the case for `find_index_list`. In the event there are multiple offsets, it needs to reset the file pointer each time, but it doesn't need to know the difference between a path and a file-like object, which is negotiated by `read_from_start`. I don't know if this will ever actually happen though, the PSI spec is a bit ambiguous.\n\nI use `re` because I couldn't reliably use `lxml` to burn through the index list since there are tons of MzML files floating around which have corrupted offsets due to an old bug in ProteoWizard, so throwing a simple regex at each line of the putative index was easier than writing another `iterparse` using function with `lxml` where error checking could be thrown in. Now that the design is more stable, I'll see if `iterparse` works reliably on both corrupted and well-formed indices, as I've got examples of both.\n\nUnfortunately, this implementation is only viable for MzML because it exploits a feature of that standard. The MzML standard explicitly includes an opt-in index of byte offsets which the file conversion software can write at the end of each MzML file. They assume we can apply this type of hacky read-from-the-end approach so that we don't have to parse the whole file in order to get to the pre-built offset index. While conceivably we could build an index for any file by trawling the bytestream with a counter and a tokenizer, this would necessarily require parsing the whole file to build, it would be highly use-case dependent whether this extra effort is worthwhile. I'll see how hard it is to do.", "markup": "markdown", "html": "<p>There's no urgency, I just got around to working out the idiosyncracies of Mercurial and BitBucket so I could make a pull request.</p>\n<p>You're correct in that <code>read_from_start</code> should probably reuse <code>_keepstate</code>. I had originally been writing this as a little one-off script and wasn't thinking about those utilities. <code>_keepstate</code> as it is right now isn't appropriate for a function which needs to reset a file-like object (or a path of a file) multiple times internally, as is the case for <code>find_index_list</code>. In the event there are multiple offsets, it needs to reset the file pointer each time, but it doesn't need to know the difference between a path and a file-like object, which is negotiated by <code>read_from_start</code>. I don't know if this will ever actually happen though, the PSI spec is a bit ambiguous.</p>\n<p>I use <code>re</code> because I couldn't reliably use <code>lxml</code> to burn through the index list since there are tons of MzML files floating around which have corrupted offsets due to an old bug in ProteoWizard, so throwing a simple regex at each line of the putative index was easier than writing another <code>iterparse</code> using function with <code>lxml</code> where error checking could be thrown in. Now that the design is more stable, I'll see if <code>iterparse</code> works reliably on both corrupted and well-formed indices, as I've got examples of both.</p>\n<p>Unfortunately, this implementation is only viable for MzML because it exploits a feature of that standard. The MzML standard explicitly includes an opt-in index of byte offsets which the file conversion software can write at the end of each MzML file. They assume we can apply this type of hacky read-from-the-end approach so that we don't have to parse the whole file in order to get to the pre-built offset index. While conceivably we could build an index for any file by trawling the bytestream with a counter and a tokenizer, this would necessarily require parsing the whole file to build, it would be highly use-case dependent whether this extra effort is worthwhile. I'll see how hard it is to do.</p>", "type": "rendered"}, "created_on": "2016-04-03T20:44:02.939729+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-03T20:44:03.031429+00:00", "type": "pullrequest_comment", "id": 16675692}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"comment": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/16674741.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-16674741"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Hi!\n\nThis looks very interesting, although I don't have the time to read it all carefully right now.\nThe idea of storing byte offsets has floated around for a while, but no one got around to implementing it before.\nMy main question (sorry if it's obvious, my mind is mostly occupied with stuff I need to be doing now) is why do we have to use regex?\nAnother thing I noticed is that your `read_from_start` is very similar to the `auxiliary._keepstate` decorator, maybe we can reuse it?\nFinally, do you think this could be generalized onto the XML class instead of mzML? `get_by_id`, for example, is mostly used in `mzid`.\n\nThank you and best regards.", "markup": "markdown", "html": "<p>Hi!</p>\n<p>This looks very interesting, although I don't have the time to read it all carefully right now.\nThe idea of storing byte offsets has floated around for a while, but no one got around to implementing it before.\nMy main question (sorry if it's obvious, my mind is mostly occupied with stuff I need to be doing now) is why do we have to use regex?\nAnother thing I noticed is that your <code>read_from_start</code> is very similar to the <code>auxiliary._keepstate</code> decorator, maybe we can reuse it?\nFinally, do you think this could be generalized onto the XML class instead of mzML? <code>get_by_id</code>, for example, is mostly used in <code>mzid</code>.</p>\n<p>Thank you and best regards.</p>", "type": "rendered"}, "created_on": "2016-04-03T20:15:26.127881+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-03T20:15:26.129989+00:00", "type": "pullrequest_comment", "id": 16674741}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "705da3129587", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/705da3129587"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/705da3129587"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-03T20:00:51.356207+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}, {"update": {"description": "This new class is derived from the original mzml.MzML reader, with a modified __init__ method\r\nto build up a byte offset index for spectra relative to the start of the file. This lets the file reader jump to the start of the spectrum immediately before parsing, removing the lengthy seek time for large files. If applied to a non-indexed MzML file, the class will fall back on its parent class methods with no loss of functionality, but without the substantial improvement in random access performance\r\nby `get_by_id`.\r\n\r\nAs a convenience notation, I also set the __getitem__ method on the IndexedMzML class to invoke `get_by_id` as the interface makes sense given the behavior, but this asymmetry with the base class may not be worth the saved characters.\r\n\r\nI added the new class to the list of callables to test in tests/test_mzml.py, where it passed the existing test suite.\r\n\r\nI made this for convenience in testing my newest problem, deisotoping and charge state determination. Every time I reset the interpreter, having to re-seek to a problematic scan took too long.", "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible.", "destination": {"commit": {"hash": "7d603942410b", "type": "commit", "links": {"self": {"href": "data/repositories/levitsky/pyteomics/commit/7d603942410b.json"}, "html": {"href": "#!/levitsky/pyteomics/commits/7d603942410b"}}}, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "705da3129587", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics/commit/705da3129587"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics/commits/705da3129587"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/mobiusklein/pyteomics"}, "html": {"href": "https://bitbucket.org/mobiusklein/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3ce101ca-5477-41e1-a7e0-d31a18922eb9}ts=python"}}, "type": "repository", "name": "pyteomics", "full_name": "mobiusklein/pyteomics", "uuid": "{3ce101ca-5477-41e1-a7e0-d31a18922eb9}"}, "branch": {"name": "default"}}, "state": "OPEN", "author": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "date": "2016-04-03T20:00:51.331488+00:00"}, "pull_request": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}}]}