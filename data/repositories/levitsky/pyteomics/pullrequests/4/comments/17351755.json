{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17351755.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17351755"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Sorry for the delay.\n\nI like the mzML part even better now that `re` is only used to find the index offset. But if I understand correctly, it will only work for valid indices.\nThe `generate_offsets` and `build_byte_index` of course raise more doubts, but in general it looks like they are the only way to go if we want to get this functionality for broken files, so we need to incorporate it somewhere in a chain of try's and except's.\n\nThe code you have in there right now is:\n\n```\n#!python\npattern = re.compile(r\"^[ ]*<(%s)\\s\" % packed)\nattrs = re.compile(r\"(\\S+)=\\\"(\\S+)\\\"\")\nfor line in file_obj:\n    match = pattern.match(line)\n```\nMy main concerns with the current patterns are:\n\n* `[ ]*` should be probably changed to `\\s*` and `\\\"(\\S+)\\\"` (for attribute values) to something like `\\\"([^\"]+)\\\"`\n* single vs double quotes. Would it be reasonable to ignore this?\n* one tag per line assumption, which was mentioned before. Can we do something like \n```\n#!python\n\npattern = re.compile(r\"\\s*<(%s)\\s((\\w)=\\\"([^\"])\\\")*\" % packed) # not tested\nfor line in file_obj:\n    for match in re.findall(pattern, line):\n        ...\n```\n\nP.S. I don't have the write permission to your fork at the moment. Also, the current code doesn't pass the test. Here are a couple of fixes:\n\n\n```\n#!diff\n\ndiff -r 8ce966e9de27 pyteomics/mzml.py\n--- a/pyteomics/mzml.py Tue Apr 12 12:46:22 2016 -0400\n+++ b/pyteomics/mzml.py Sun Apr 17 21:10:19 2016 +0300\n@@ -63,13 +63,10 @@\n import numpy as np\n import zlib\n import base64\n+import re\n from . import xml, auxiliary as aux\n from .xml import etree\n \n@@ -270,7 +267,7 @@\n     \"\"\"\n     file_obj.seek(-1024, 2)\n     text = file_obj.read(1024)\n-    index_offsets = list(map(int, re.findall(r\"<indexListOffset>(\\d+)</indexListOffset>\", text)))\n+    index_offsets = list(map(int, re.findall(br\"<indexListOffset>(\\d+)</indexListOffset>\", text)))\n     return index_offsets\n \n \n@@ -390,7 +387,7 @@\n             elem = self._find_by_id_no_reset(elem_id)\n             data = self._get_info_smart(elem, recursive=True)\n             return data\n-        except KeyError, etree.LxmlError:\n+        except (KeyError, etree.LxmlError):\n             return super(IndexedMzML, self).get_by_id(elem_id)\n \n     def __getitem__(self, elem_id):\n```\n\nThe parentheses in `except` are needed in Python 3, and also in Python 3 the file mode makes more difference, so we can't search for a string in binary file.\nWe probably need to carefully address the fact that XML files are opened in binary mode by default and the matching is done using strings. Maybe just changing everything to byte literals will be enough.\nAlso, in Python 3 we'll need to import `basestring` from `.auxiliary`.", "markup": "markdown", "html": "<p>Sorry for the delay.</p>\n<p>I like the mzML part even better now that <code>re</code> is only used to find the index offset. But if I understand correctly, it will only work for valid indices.\nThe <code>generate_offsets</code> and <code>build_byte_index</code> of course raise more doubts, but in general it looks like they are the only way to go if we want to get this functionality for broken files, so we need to incorporate it somewhere in a chain of try's and except's.</p>\n<p>The code you have in there right now is:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;^[ ]*&lt;(</span><span class=\"si\">%s</span><span class=\"s2\">)\\s&quot;</span> <span class=\"o\">%</span> <span class=\"n\">packed</span><span class=\"p\">)</span>\n<span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;(\\S+)=</span><span class=\"se\">\\&quot;</span><span class=\"s2\">(\\S+)</span><span class=\"se\">\\&quot;</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">file_obj</span><span class=\"p\">:</span>\n    <span class=\"n\">match</span> <span class=\"o\">=</span> <span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>My main concerns with the current patterns are:</p>\n<ul>\n<li><code>[ ]*</code> should be probably changed to <code>\\s*</code> and <code>\\\"(\\S+)\\\"</code> (for attribute values) to something like <code>\\\"([^\"]+)\\\"</code></li>\n<li>single vs double quotes. Would it be reasonable to ignore this?</li>\n<li>one tag per line assumption, which was mentioned before. Can we do something like </li>\n</ul>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;\\s*&lt;(</span><span class=\"si\">%s</span><span class=\"s2\">)\\s((\\w)=</span><span class=\"se\">\\&quot;</span><span class=\"s2\">([^&quot;</span><span class=\"p\">])</span>\\<span class=\"s2\">&quot;)*&quot;</span> <span class=\"o\">%</span> <span class=\"n\">packed</span><span class=\"p\">)</span> <span class=\"c1\"># not tested</span>\n<span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">file_obj</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">match</span> <span class=\"ow\">in</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">findall</span><span class=\"p\">(</span><span class=\"n\">pattern</span><span class=\"p\">,</span> <span class=\"n\">line</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n</pre></div>\n\n\n<p>P.S. I don't have the write permission to your fork at the moment. Also, the current code doesn't pass the test. Here are a couple of fixes:</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r 8ce966e9de27 pyteomics/mzml.py</span>\n<span class=\"gd\">--- a/pyteomics/mzml.py Tue Apr 12 12:46:22 2016 -0400</span>\n<span class=\"gi\">+++ b/pyteomics/mzml.py Sun Apr 17 21:10:19 2016 +0300</span>\n<span class=\"gu\">@@ -63,13 +63,10 @@</span>\n import numpy as np\n import zlib\n import base64\n<span class=\"gi\">+import re</span>\n from . import xml, auxiliary as aux\n from .xml import etree\n\n<span class=\"gu\">@@ -270,7 +267,7 @@</span>\n     &quot;&quot;&quot;\n     file_obj.seek(-1024, 2)\n     text = file_obj.read(1024)\n<span class=\"gd\">-    index_offsets = list(map(int, re.findall(r&quot;&lt;indexListOffset&gt;(\\d+)&lt;/indexListOffset&gt;&quot;, text)))</span>\n<span class=\"gi\">+    index_offsets = list(map(int, re.findall(br&quot;&lt;indexListOffset&gt;(\\d+)&lt;/indexListOffset&gt;&quot;, text)))</span>\n     return index_offsets\n\n\n<span class=\"gu\">@@ -390,7 +387,7 @@</span>\n             elem = self._find_by_id_no_reset(elem_id)\n             data = self._get_info_smart(elem, recursive=True)\n             return data\n<span class=\"gd\">-        except KeyError, etree.LxmlError:</span>\n<span class=\"gi\">+        except (KeyError, etree.LxmlError):</span>\n             return super(IndexedMzML, self).get_by_id(elem_id)\n\n     def __getitem__(self, elem_id):\n</pre></div>\n\n\n<p>The parentheses in <code>except</code> are needed in Python 3, and also in Python 3 the file mode makes more difference, so we can't search for a string in binary file.\nWe probably need to carefully address the fact that XML files are opened in binary mode by default and the matching is done using strings. Maybe just changing everything to byte literals will be enough.\nAlso, in Python 3 we'll need to import <code>basestring</code> from <code>.auxiliary</code>.</p>", "type": "rendered"}, "created_on": "2016-04-17T18:19:08.536697+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-17T18:19:08.539438+00:00", "type": "pullrequest_comment", "id": 17351755}