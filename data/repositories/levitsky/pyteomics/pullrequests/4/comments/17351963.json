{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17351963.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17351963"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "I've given you write permission.\n\nYes, I routinely make these mistakes with strings for Python3 sources since I still work primarily on 2.7. Over the summer, when there aren't any pressing deadlines, I'll update my projects to work on Python 3.5, so this should come to an end soon.\n\nI've never seen Proteowizard generate an XML file with multiple tags on the same line, but it's not impossible. I'll see how well behaved the code is after changing to `findall`.\n\nI tried the following approach to byte counting incrementally in pure Python since the XML parser approach failed.\n\n```python\nclass BufferedByteStreamReader(object):\n    attr_pattern = re.compile(r\"(\\S+)=\\\"(\\S+)\\\"\")\n\n    def __init__(self, stream, target_tag):\n        self.stream = stream\n        self.current_offset = 0\n        self.target_tag = target_tag\n        self.target_buffer = \"<\" + target_tag + ' '\n        self.buffer_length = len(self.target_buffer)\n        self.buffer = deque()\n\n    def parse(self):\n        i = 0\n        self.current_offset = self.buffer_length\n        self.buffer.extend(self.stream.read(self.buffer_length))\n        joiner = ''.join\n        while True:\n            i += 1\n            if (self.buffer[0] == self.target_buffer[0]) and\\\n               (self.buffer[1] == self.target_buffer[1]) and\\\n               (self.buffer[2] == self.target_buffer[2]):\n                if joiner(self.buffer) == self.target_buffer:\n                    offset = self.current_offset - self.buffer_length\n                    rest = self.complete_tag()\n                    tag = joiner(list(self.buffer) + rest)\n                    attrs = self.extract_attributes(tag)\n                    self.buffer = deque(self.stream.read(self.buffer_length))\n                    self.current_offset += self.buffer_length\n                    yield offset, attrs\n\n            self.buffer.popleft()\n            self.buffer.append(self.stream.read(1))\n            self.current_offset += 1\n\n    def complete_tag(self):\n        charbuffer = []\n        parse = True\n        while parse:\n            char = self.stream.read(1)\n            if char == \">\":\n                parse = False\n            self.current_offset += 1\n            charbuffer.append(char)\n        return charbuffer\n\n    def extract_attributes(self, tag):\n        return dict(self.attr_pattern.findall(tag))\n```\n\nUnfortunately, it really is too slow to be practical for mzML. It could still work for smaller files like mzIdentML, and would be able to handle more pathological cases than the line-based reader. That said, I assumed that the `file` object was really buffered internally as well, which I think is the case from reading the standard library's `io` documentation. Otherwise, all of the calls I made to `file.read` with small byte counts are going to be massively wasteful.", "markup": "markdown", "html": "<p>I've given you write permission.</p>\n<p>Yes, I routinely make these mistakes with strings for Python3 sources since I still work primarily on 2.7. Over the summer, when there aren't any pressing deadlines, I'll update my projects to work on Python 3.5, so this should come to an end soon.</p>\n<p>I've never seen Proteowizard generate an XML file with multiple tags on the same line, but it's not impossible. I'll see how well behaved the code is after changing to <code>findall</code>.</p>\n<p>I tried the following approach to byte counting incrementally in pure Python since the XML parser approach failed.</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">BufferedByteStreamReader</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"n\">attr_pattern</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;(\\S+)=</span><span class=\"se\">\\&quot;</span><span class=\"s2\">(\\S+)</span><span class=\"se\">\\&quot;</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">stream</span><span class=\"p\">,</span> <span class=\"n\">target_tag</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span> <span class=\"o\">=</span> <span class=\"n\">stream</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_tag</span> <span class=\"o\">=</span> <span class=\"n\">target_tag</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;&lt;&quot;</span> <span class=\"o\">+</span> <span class=\"n\">target_tag</span> <span class=\"o\">+</span> <span class=\"s1\">&#39; &#39;</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">deque</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">parse</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span><span class=\"p\">))</span>\n        <span class=\"n\">joiner</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span>\n        <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"ow\">and</span>\\\n               <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span> <span class=\"ow\">and</span>\\\n               <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]):</span>\n                <span class=\"k\">if</span> <span class=\"n\">joiner</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">target_buffer</span><span class=\"p\">:</span>\n                    <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">-</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span>\n                    <span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">complete_tag</span><span class=\"p\">()</span>\n                    <span class=\"n\">tag</span> <span class=\"o\">=</span> <span class=\"n\">joiner</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">rest</span><span class=\"p\">)</span>\n                    <span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">extract_attributes</span><span class=\"p\">(</span><span class=\"n\">tag</span><span class=\"p\">)</span>\n                    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">deque</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span><span class=\"p\">))</span>\n                    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer_length</span>\n                    <span class=\"k\">yield</span> <span class=\"n\">offset</span><span class=\"p\">,</span> <span class=\"n\">attrs</span>\n\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">popleft</span><span class=\"p\">()</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">complete_tag</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">charbuffer</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">parse</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>\n        <span class=\"k\">while</span> <span class=\"n\">parse</span><span class=\"p\">:</span>\n            <span class=\"n\">char</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">char</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;&gt;&quot;</span><span class=\"p\">:</span>\n                <span class=\"n\">parse</span> <span class=\"o\">=</span> <span class=\"bp\">False</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">current_offset</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">charbuffer</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">char</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">charbuffer</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">extract_attributes</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">tag</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">attr_pattern</span><span class=\"o\">.</span><span class=\"n\">findall</span><span class=\"p\">(</span><span class=\"n\">tag</span><span class=\"p\">))</span>\n</pre></div>\n\n\n<p>Unfortunately, it really is too slow to be practical for mzML. It could still work for smaller files like mzIdentML, and would be able to handle more pathological cases than the line-based reader. That said, I assumed that the <code>file</code> object was really buffered internally as well, which I think is the case from reading the standard library's <code>io</code> documentation. Otherwise, all of the calls I made to <code>file.read</code> with small byte counts are going to be massively wasteful.</p>", "type": "rendered"}, "created_on": "2016-04-17T18:53:25.781244+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-17T18:53:25.916000+00:00", "type": "pullrequest_comment", "id": 17351963}