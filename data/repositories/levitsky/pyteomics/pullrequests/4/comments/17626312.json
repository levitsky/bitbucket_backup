{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17626312.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17626312"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Error handling for building mzML byte index from the provided offsets when the XML is malformed is handled in `mzml._iterparse_index_list`.  Something missing from the offset index is handled in `IndexedXML.get_by_id`, which is common to all `IndexedXML` subclasses.\n\n`IndexedXML.get_by_id` first tries to find a byte offset for the given id, looking it up in `._offset_index`. It then seeks the file point to that byte offset and then starts iterparsing from that point with `_find_by_id_no_reset` which is just an iterparse method. If the id isn't found in the index (KeyError), or if there is an XML parsing error (LxmlError), then it attempts to parse from the start of the file using `_find_by_id_reset`, which is just a decorated `@_keepstate` version of `_find_by_id_no_reset`. I found calling `super().get_by_id` was not resetting the file pointer through the decorator on `XML.get_by_id` so I redid it in `IndexedXML`.\n\nIt's entirely possible `pympler` isn't getting the right size for a C struct since `sizeof` on a pointer to a C struct will just be `sizeof(size_t)` or 8 bytes on my machine, roughly the same size as the byte offset. The items in all the caches are the same. I intentionally cached every tag type that were used. If I cache only the biggest cases like `PeptideEvidence` and `SpectrumIdentificationItem`, the size savings is closer 60% but there is a cost in speed which may depend upon which tag you want to iterate over. For `ProteinDetectionHypothesis`, it was just over 15% slower.\n\nYes, I made the mistake of omitting the `b` prefix on those in `IndexedMzIdentML._indexed_tags`, which I'm using for the default set of tags to cache for derived classes. Previously, you'd have needed to subclass the type in order to change what was indexed. I've changed the `IndexedXML` to take an optional keyword argument `indexed_tags` to take the names of tags to cache, so users can configure it on a per-instance basis. \n\nI added a function to ensure that the indexed tag names are converted into bytes:\n\n```python\ndef ensure_bytes(strings):\n    if isinstance(strings, (basestring)):\n        strings = [strings]\n    results = []\n    for string in strings:\n        try:\n            results.append(string.encode(\"utf-8\"))\n        except:\n            if isinstance(string, bytes):\n                results.append(string)\n            else:\n                warnings.warn(\"%r could not be decoded\" % string)\n    return results\n```\n\nwhich will be called on `IndexedXML.__init__`\n\nI may be writing too much C recently. I'll look at reimplementing those functions as an object.\n\n\n", "markup": "markdown", "html": "<p>Error handling for building mzML byte index from the provided offsets when the XML is malformed is handled in <code>mzml._iterparse_index_list</code>.  Something missing from the offset index is handled in <code>IndexedXML.get_by_id</code>, which is common to all <code>IndexedXML</code> subclasses.</p>\n<p><code>IndexedXML.get_by_id</code> first tries to find a byte offset for the given id, looking it up in <code>._offset_index</code>. It then seeks the file point to that byte offset and then starts iterparsing from that point with <code>_find_by_id_no_reset</code> which is just an iterparse method. If the id isn't found in the index (KeyError), or if there is an XML parsing error (LxmlError), then it attempts to parse from the start of the file using <code>_find_by_id_reset</code>, which is just a decorated <code>@_keepstate</code> version of <code>_find_by_id_no_reset</code>. I found calling <code>super().get_by_id</code> was not resetting the file pointer through the decorator on <code>XML.get_by_id</code> so I redid it in <code>IndexedXML</code>.</p>\n<p>It's entirely possible <code>pympler</code> isn't getting the right size for a C struct since <code>sizeof</code> on a pointer to a C struct will just be <code>sizeof(size_t)</code> or 8 bytes on my machine, roughly the same size as the byte offset. The items in all the caches are the same. I intentionally cached every tag type that were used. If I cache only the biggest cases like <code>PeptideEvidence</code> and <code>SpectrumIdentificationItem</code>, the size savings is closer 60% but there is a cost in speed which may depend upon which tag you want to iterate over. For <code>ProteinDetectionHypothesis</code>, it was just over 15% slower.</p>\n<p>Yes, I made the mistake of omitting the <code>b</code> prefix on those in <code>IndexedMzIdentML._indexed_tags</code>, which I'm using for the default set of tags to cache for derived classes. Previously, you'd have needed to subclass the type in order to change what was indexed. I've changed the <code>IndexedXML</code> to take an optional keyword argument <code>indexed_tags</code> to take the names of tags to cache, so users can configure it on a per-instance basis. </p>\n<p>I added a function to ensure that the indexed tag names are converted into bytes:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">ensure_bytes</span><span class=\"p\">(</span><span class=\"n\">strings</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">strings</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nb\">basestring</span><span class=\"p\">)):</span>\n        <span class=\"n\">strings</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">strings</span><span class=\"p\">]</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">string</span> <span class=\"ow\">in</span> <span class=\"n\">strings</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">results</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s2\">&quot;utf-8&quot;</span><span class=\"p\">))</span>\n        <span class=\"k\">except</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">):</span>\n                <span class=\"n\">results</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">)</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">warnings</span><span class=\"o\">.</span><span class=\"n\">warn</span><span class=\"p\">(</span><span class=\"s2\">&quot;</span><span class=\"si\">%r</span><span class=\"s2\"> could not be decoded&quot;</span> <span class=\"o\">%</span> <span class=\"n\">string</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">results</span>\n</pre></div>\n\n\n<p>which will be called on <code>IndexedXML.__init__</code></p>\n<p>I may be writing too much C recently. I'll look at reimplementing those functions as an object.</p>", "type": "rendered"}, "created_on": "2016-04-22T15:01:57.559530+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-22T15:01:57.708121+00:00", "type": "pullrequest_comment", "id": 17626312}