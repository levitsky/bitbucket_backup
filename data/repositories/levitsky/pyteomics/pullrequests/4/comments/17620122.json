{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/17620122.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-17620122"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "I like this implementation a lot. Questions:\n\n* error handling machinery for mzML is not in place yet, is that right or am I missing something?\n\n* I don't quite get the idea behind `_find_by_id_no_reset` vs `_find_by_id_reset`. Why do we need them and why is one in the `try` and the other in the `except`?\n\n* 30% is nice, but I kind of expected more. Are lxml elements really so compact or is it an unfair comparison? Is the number of elements the same in the two caches?\n\n* The test for `mzid` fails because of yet another bytes-string issue:\n\n\n```\n#!python\n\n  File \".../pyteomics/xml.py\", line 604, in generate_offsets\n    packed = b\"|\".join(names)\nTypeError: sequence item 0: expected a bytes-like object, str found\n```\nApparently this is because the indexed tags are strings. I don't think they need to be bytes, I'd rather have them explicitly encoded to ASCII somewhere in `__init__` or elsewhere.\n\nCompletely unimportant: do you think it makes sense to have `build_byte_index`, `generate_offsets` and `_index_finding_chunker` as free functions and not methods of `TagSpecificXMLByteIndex`, for example?\nAlso, don't we want to initialize `TagSpecificXMLByteIndex` with a file object, like we do with `XML` and such?", "markup": "markdown", "html": "<p>I like this implementation a lot. Questions:</p>\n<ul>\n<li>\n<p>error handling machinery for mzML is not in place yet, is that right or am I missing something?</p>\n</li>\n<li>\n<p>I don't quite get the idea behind <code>_find_by_id_no_reset</code> vs <code>_find_by_id_reset</code>. Why do we need them and why is one in the <code>try</code> and the other in the <code>except</code>?</p>\n</li>\n<li>\n<p>30% is nice, but I kind of expected more. Are lxml elements really so compact or is it an unfair comparison? Is the number of elements the same in the two caches?</p>\n</li>\n<li>\n<p>The test for <code>mzid</code> fails because of yet another bytes-string issue:</p>\n</li>\n</ul>\n<div class=\"codehilite language-python\"><pre><span></span>  <span class=\"n\">File</span> <span class=\"s2\">&quot;.../pyteomics/xml.py&quot;</span><span class=\"p\">,</span> <span class=\"n\">line</span> <span class=\"mi\">604</span><span class=\"p\">,</span> <span class=\"ow\">in</span> <span class=\"n\">generate_offsets</span>\n    <span class=\"n\">packed</span> <span class=\"o\">=</span> <span class=\"sa\">b</span><span class=\"s2\">&quot;|&quot;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">names</span><span class=\"p\">)</span>\n<span class=\"ne\">TypeError</span><span class=\"p\">:</span> <span class=\"n\">sequence</span> <span class=\"n\">item</span> <span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"n\">expected</span> <span class=\"n\">a</span> <span class=\"nb\">bytes</span><span class=\"o\">-</span><span class=\"n\">like</span> <span class=\"nb\">object</span><span class=\"p\">,</span> <span class=\"nb\">str</span> <span class=\"n\">found</span>\n</pre></div>\n\n\n<p>Apparently this is because the indexed tags are strings. I don't think they need to be bytes, I'd rather have them explicitly encoded to ASCII somewhere in <code>__init__</code> or elsewhere.</p>\n<p>Completely unimportant: do you think it makes sense to have <code>build_byte_index</code>, <code>generate_offsets</code> and <code>_index_finding_chunker</code> as free functions and not methods of <code>TagSpecificXMLByteIndex</code>, for example?\nAlso, don't we want to initialize <code>TagSpecificXMLByteIndex</code> with a file object, like we do with <code>XML</code> and such?</p>", "type": "rendered"}, "created_on": "2016-04-22T13:26:25.938017+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": "2016-04-22T13:26:25.940439+00:00", "type": "pullrequest_comment", "id": 17620122}