{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4/comments/16861871.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4/_/diff#comment-16861871"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/4.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/4"}}, "title": "Added an IndexedMzML class to make random access of indexed MzML documents possible."}, "content": {"raw": "Attempting to build up an index of byte offsets with `lxml` is not possible since it only reports source lines. The standard library's `expat` bindings looked promising, but failed in the end because they use a *signed* `long` to report byte offsets, so it would involve both overflow detection and sign correction in a platform dependent fashion. Attempting to trick either of these libraries into advancing a file pointer did not work as the `file.tell()` call after each yielded tag did not line up with the tag. In the end, iterating over the lines of the file and counting the characters per line, using a regular expression to detect when a tag of interest was found.\n\n```python\ndef generate_offsets(file_obj, names):\n    \"\"\"\n    Iterate over the lines of an XML file where each line contains exactly one tag,\n    tracking the byte count for each line. When a line contains a tag whose name matches\n    a name in `names`, yield the byte offset, the tag type, and it's attributes.\n\n    Parameters\n    ----------\n    file_obj : file\n        File to parse\n    names : str or iterable of str\n        The name or names to yield byte offsets for\n\n    Yields\n    ------\n    offset : int\n        The byte offset of a matched tag's opening line\n    tag_type : str\n        The type of tag matched\n    attr_dict : dict\n        The attributes on the matched tag\n    \"\"\"\n    i = 0\n    if isinstance(names, basestring):\n        names = [names]\n    packed = \"|\".join(names)\n    pattern = re.compile(r\"^[ ]*<(%s)\\s\" % packed)\n    attrs = re.compile(r\"(\\S+)=\\\"(\\S+)\\\"\")\n    for line in file_obj:\n        match = pattern.match(line)\n        if match:\n            yield i, match.group(1), dict(attrs.findall(line))\n        i += len(line)\n```\n\nThis method burned through the file faster than `expat` because it wasn't trying to completely parse every line. It's only downside is that it requires the file to contain new line characters, which are not mandatory for well formed XML. I was able to use these offsets to properly seek each `spectrum` and `chromatogram` tag and it can also be applied to other XML files. If this approach seems okay to you, I'll add it to the `xml` module and mint a new `IndexedXML` class whose `get_by_id` method first checks the id cache, then the byte offset index, and then iterparse.\n", "markup": "markdown", "html": "<p>Attempting to build up an index of byte offsets with <code>lxml</code> is not possible since it only reports source lines. The standard library's <code>expat</code> bindings looked promising, but failed in the end because they use a <em>signed</em> <code>long</code> to report byte offsets, so it would involve both overflow detection and sign correction in a platform dependent fashion. Attempting to trick either of these libraries into advancing a file pointer did not work as the <code>file.tell()</code> call after each yielded tag did not line up with the tag. In the end, iterating over the lines of the file and counting the characters per line, using a regular expression to detect when a tag of interest was found.</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">generate_offsets</span><span class=\"p\">(</span><span class=\"n\">file_obj</span><span class=\"p\">,</span> <span class=\"n\">names</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Iterate over the lines of an XML file where each line contains exactly one tag,</span>\n<span class=\"sd\">    tracking the byte count for each line. When a line contains a tag whose name matches</span>\n<span class=\"sd\">    a name in `names`, yield the byte offset, the tag type, and it&#39;s attributes.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    file_obj : file</span>\n<span class=\"sd\">        File to parse</span>\n<span class=\"sd\">    names : str or iterable of str</span>\n<span class=\"sd\">        The name or names to yield byte offsets for</span>\n\n<span class=\"sd\">    Yields</span>\n<span class=\"sd\">    ------</span>\n<span class=\"sd\">    offset : int</span>\n<span class=\"sd\">        The byte offset of a matched tag&#39;s opening line</span>\n<span class=\"sd\">    tag_type : str</span>\n<span class=\"sd\">        The type of tag matched</span>\n<span class=\"sd\">    attr_dict : dict</span>\n<span class=\"sd\">        The attributes on the matched tag</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">names</span><span class=\"p\">,</span> <span class=\"nb\">basestring</span><span class=\"p\">):</span>\n        <span class=\"n\">names</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">names</span><span class=\"p\">]</span>\n    <span class=\"n\">packed</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;|&quot;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">names</span><span class=\"p\">)</span>\n    <span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;^[ ]*&lt;(</span><span class=\"si\">%s</span><span class=\"s2\">)\\s&quot;</span> <span class=\"o\">%</span> <span class=\"n\">packed</span><span class=\"p\">)</span>\n    <span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">&quot;(\\S+)=</span><span class=\"se\">\\&quot;</span><span class=\"s2\">(\\S+)</span><span class=\"se\">\\&quot;</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">file_obj</span><span class=\"p\">:</span>\n        <span class=\"n\">match</span> <span class=\"o\">=</span> <span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">match</span><span class=\"p\">:</span>\n            <span class=\"k\">yield</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">match</span><span class=\"o\">.</span><span class=\"n\">group</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">attrs</span><span class=\"o\">.</span><span class=\"n\">findall</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">))</span>\n        <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>This method burned through the file faster than <code>expat</code> because it wasn't trying to completely parse every line. It's only downside is that it requires the file to contain new line characters, which are not mandatory for well formed XML. I was able to use these offsets to properly seek each <code>spectrum</code> and <code>chromatogram</code> tag and it can also be applied to other XML files. If this approach seems okay to you, I'll add it to the <code>xml</code> module and mint a new <code>IndexedXML</code> class whose <code>get_by_id</code> method first checks the id cache, then the byte offset index, and then iterparse.</p>", "type": "rendered"}, "created_on": "2016-04-06T14:11:16.724217+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2016-04-06T14:11:16.863996+00:00", "type": "pullrequest_comment", "id": 16861871}