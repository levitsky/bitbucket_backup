{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/25/comments/76079707.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/25/_/diff#comment-76079707"}}, "parent": {"id": 76078537, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/25/comments/76078537.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/25/_/diff#comment-76078537"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 25, "links": {"self": {"href": "data/repositories/levitsky/pyteomics/pullrequests/25.json"}, "html": {"href": "#!/levitsky/pyteomics/pull-requests/25"}}, "title": "Update for 4.0"}, "content": {"raw": "By string slice, do you mean `\"a\":\"f\"  = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]`?\nI'm not sure I see how to translate that this. Maybe slices where start and\nstop are scan ID strings, and then accumulating all IDs between them?\n\nSupporting this type of rich data set access is moving away from \"parsing\ndata\" into essentially \"abstract data collection access independent of disk\nformat\", basically moving towards composing data extraction and\ntransformation operations in the form of Python expressions like SymPy,\nSQLAlchemy or one of the hundred matrix/vector expression compilers, which\nI won't lie and say I didn't think about, but I then I had to back up\nbecause that type of abstraction requires *a lot* of code bordering on\nwriting your own sub-language, and in our case, it'd still be executing\nPython code, not SQL, or a numerical VM.", "markup": "markdown", "html": "<p>By string slice, do you mean <code>\"a\":\"f\"  = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]</code>?\nI'm not sure I see how to translate that this. Maybe slices where start and\nstop are scan ID strings, and then accumulating all IDs between them?</p>\n<p>Supporting this type of rich data set access is moving away from \"parsing\ndata\" into essentially \"abstract data collection access independent of disk\nformat\", basically moving towards composing data extraction and\ntransformation operations in the form of Python expressions like SymPy,\nSQLAlchemy or one of the hundred matrix/vector expression compilers, which\nI won't lie and say I didn't think about, but I then I had to back up\nbecause that type of abstraction requires <em>a lot</em> of code bordering on\nwriting your own sub-language, and in our case, it'd still be executing\nPython code, not SQL, or a numerical VM.</p>", "type": "rendered"}, "created_on": "2018-09-14T21:25:13.727782+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2018-09-14T21:25:13.772510+00:00", "type": "pullrequest_comment", "id": 76079707}