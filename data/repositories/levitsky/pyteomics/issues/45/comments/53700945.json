{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/45/comments/53700945.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/45#comment-53700945"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/45.json"}}, "type": "issue", "id": 45, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "Pyteomics cparser.isoforms module feature request"}, "content": {"raw": "After a few tries, I've observed that the two real bottleneck are re-allocating the `list` that holds the sequence, and manipulating the sequence structure. Using static typing and a data structure that knows more about its terminal modification state, manipulating the sequence structure is reasonably quick, around 50% faster. \n\nThe other bottleneck is harder to fix without totally changing the function's behavior. When you use the existing `isoforms` function, each iteration has to copy the entire sequence list, and then replace the positions to be modified in that next iteration. For short sequences, that copy operation is negligible, but for long sequences like the ones you\u2019re dealing with, the copy operation is way more expensive than applying the modifications. If I could assume that the list was not going to be saved without an external copy being made in the next iteration, I could probably get another 40-50% improvement by just re-using the existing list from one iteration to the next. It does complicate the book keeping slightly though.", "markup": "markdown", "html": "<p>After a few tries, I've observed that the two real bottleneck are re-allocating the <code>list</code> that holds the sequence, and manipulating the sequence structure. Using static typing and a data structure that knows more about its terminal modification state, manipulating the sequence structure is reasonably quick, around 50% faster. </p>\n<p>The other bottleneck is harder to fix without totally changing the function's behavior. When you use the existing <code>isoforms</code> function, each iteration has to copy the entire sequence list, and then replace the positions to be modified in that next iteration. For short sequences, that copy operation is negligible, but for long sequences like the ones you\u2019re dealing with, the copy operation is way more expensive than applying the modifications. If I could assume that the list was not going to be saved without an external copy being made in the next iteration, I could probably get another 40-50% improvement by just re-using the existing list from one iteration to the next. It does complicate the book keeping slightly though.</p>", "type": "rendered"}, "created_on": "2019-09-01T22:14:18.450370+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": null, "type": "issue_comment", "id": 53700945}