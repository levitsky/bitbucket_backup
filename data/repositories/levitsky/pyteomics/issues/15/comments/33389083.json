{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15/comments/33389083.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/15#comment-33389083"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "cvParam Unit Awareness"}, "content": {"raw": "Schema value types, taken from the document XSDs, are abstract datatypes in their own right. Some are directly mappable to primitive types, as we do. Others might be compound datatypes, which are made up of compositions of elements. They might imply units, but they *must* be consistent or somehow encoded by another property of the document. For PSI XML, this kind of design was superseded by these semantic parameters. This is *not* the case for `mzXML` where they do things like encode time in a string with the prefix \"PT\" and suffix \"S\" (for seconds) wrapped around a floating point number, where the XSD description of these attributes is \"time duration type\". That means that documents like that require special handling. I might address that for mzXML if I can find full documentation. Doing that generally is beyond the scope of the work I propose to do. \n\nAs for mixing unit- and plain value types, it would make a cleaner API if everything were consistent. That could be handled in `xml.XMLValueConverter` where `unit_info` is just set to `None` since units cannot be inferred automatically. I'm tempted to ignore this case because \"the user will know when to expect a unit and when not to\", but I think that because I've had to study the schemas for the document types I use, and if I were to be exposed to a new document type tomorrow, without documentation about different values, I'd probably want to not guess at whether a value had a unit.\n\n`userParam`'s `type` field is an inline XSD specification for that tag's value, since by definition, `userParam`s cannot be pre-specified.\n```xml\n<userParam name=\"[Thermo Trailer Extra]Monoisotopic M/Z:\" value=\"810.41522216796875\" type=\"xsd:float\"/>\n```\n`cvParam`'s identity implies the data type in its CV definition:\n\n```text\n[Term]\nid: MS:1000041\nname: charge state\ndef: \"The charge state of the ion, single or multiple and positive or negatively charged.\" [PSI:MS]\nsynonym: \"z\" EXACT []\nxref: value-type:xsd\\:int \"The allowed value-type for this CV term.\" # <-- data type\nis_a: MS:1000455 ! ion selection attribute\n```\nAs it happens, we don't use this information since the parsers don't access the CV to resolve terms, so we always make them `float` if numeric or `str` otherwise (snippet of `_handle_param`):\n```python\n if 'value' in element.attrib:\n            try:\n                if element.attrib.get('type') in types:  # If the type is specified, as in userParam\n                    value = types[element.attrib['type']](element.attrib['value'])\n                else: # Otherwise treat it like a float\n                    value = float(element.attrib['value'])\n            except ValueError:\n                value = element.attrib['value']  # Handle the case where it cannot be converted into a numeric value from a string by just leaving it as a string\n            return {element.attrib['name']: value}\n```\n```xml\n<selectedIon>\n  <cvParam cvRef=\"MS\" accession=\"MS:1000744\" name=\"selected ion m/z\" value=\"1061.424072265625\" unitCvRef=\"MS\" unitAccession=\"MS:1000040\" unitName=\"m/z\"/>\n  <cvParam cvRef=\"MS\" accession=\"MS:1000041\" name=\"charge state\" value=\"3\"/> <!-- will be converted to float instead int -->\n  <cvParam cvRef=\"MS\" accession=\"MS:1000042\" name=\"peak intensity\" value=\"7.069659375e05\" unitCvRef=\"MS\" unitAccession=\"MS:1000131\" unitName=\"number of detector counts\"/>\n</selectedIon>\n```", "markup": "markdown", "html": "<p>Schema value types, taken from the document XSDs, are abstract datatypes in their own right. Some are directly mappable to primitive types, as we do. Others might be compound datatypes, which are made up of compositions of elements. They might imply units, but they <em>must</em> be consistent or somehow encoded by another property of the document. For PSI XML, this kind of design was superseded by these semantic parameters. This is <em>not</em> the case for <code>mzXML</code> where they do things like encode time in a string with the prefix \"PT\" and suffix \"S\" (for seconds) wrapped around a floating point number, where the XSD description of these attributes is \"time duration type\". That means that documents like that require special handling. I might address that for mzXML if I can find full documentation. Doing that generally is beyond the scope of the work I propose to do. </p>\n<p>As for mixing unit- and plain value types, it would make a cleaner API if everything were consistent. That could be handled in <code>xml.XMLValueConverter</code> where <code>unit_info</code> is just set to <code>None</code> since units cannot be inferred automatically. I'm tempted to ignore this case because \"the user will know when to expect a unit and when not to\", but I think that because I've had to study the schemas for the document types I use, and if I were to be exposed to a new document type tomorrow, without documentation about different values, I'd probably want to not guess at whether a value had a unit.</p>\n<p><code>userParam</code>'s <code>type</code> field is an inline XSD specification for that tag's value, since by definition, <code>userParam</code>s cannot be pre-specified.</p>\n<div class=\"codehilite language-xml\"><pre><span></span><span class=\"nt\">&lt;userParam</span> <span class=\"na\">name=</span><span class=\"s\">&quot;[Thermo Trailer Extra]Monoisotopic M/Z:&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;810.41522216796875&quot;</span> <span class=\"na\">type=</span><span class=\"s\">&quot;xsd:float&quot;</span><span class=\"nt\">/&gt;</span>\n</pre></div>\n\n\n<p><code>cvParam</code>'s identity implies the data type in its CV definition:</p>\n<div class=\"codehilite language-text\"><pre><span></span>[Term]\nid: MS:1000041\nname: charge state\ndef: &quot;The charge state of the ion, single or multiple and positive or negatively charged.&quot; [PSI:MS]\nsynonym: &quot;z&quot; EXACT []\nxref: value-type:xsd\\:int &quot;The allowed value-type for this CV term.&quot; # &lt;-- data type\nis_a: MS:1000455 ! ion selection attribute\n</pre></div>\n\n\n<p>As it happens, we don't use this information since the parsers don't access the CV to resolve terms, so we always make them <code>float</code> if numeric or <code>str</code> otherwise (snippet of <code>_handle_param</code>):</p>\n<div class=\"codehilite language-python\"><pre><span></span> <span class=\"k\">if</span> <span class=\"s1\">&#39;value&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;type&#39;</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">:</span>  <span class=\"c1\"># If the type is specified, as in userParam</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">types</span><span class=\"p\">[</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;type&#39;</span><span class=\"p\">]](</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">])</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span> <span class=\"c1\"># Otherwise treat it like a float</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">])</span>\n            <span class=\"k\">except</span> <span class=\"ne\">ValueError</span><span class=\"p\">:</span>\n                <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">]</span>  <span class=\"c1\"># Handle the case where it cannot be converted into a numeric value from a string by just leaving it as a string</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;name&#39;</span><span class=\"p\">]:</span> <span class=\"n\">value</span><span class=\"p\">}</span>\n</pre></div>\n\n\n<div class=\"codehilite language-xml\"><pre><span></span><span class=\"nt\">&lt;selectedIon&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1000744&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;selected ion m/z&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;1061.424072265625&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;MS:1000040&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;m/z&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1000041&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;charge state&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;3&quot;</span><span class=\"nt\">/&gt;</span> <span class=\"c\">&lt;!-- will be converted to float instead int --&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1000042&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;peak intensity&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;7.069659375e05&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;MS:1000131&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;number of detector counts&quot;</span><span class=\"nt\">/&gt;</span>\n<span class=\"nt\">&lt;/selectedIon&gt;</span>\n</pre></div>", "type": "rendered"}, "created_on": "2017-01-05T18:01:00.751871+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": null, "type": "issue_comment", "id": 33389083}