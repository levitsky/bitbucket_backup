{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15/comments/33370570.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/15#comment-33370570"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "cvParam Unit Awareness"}, "content": {"raw": "The functionality I intend to add is just using a wrapper type instead of a straight primitive type for storing the value of unit-annotated cvParams. Unit conversion is something that can be left to the application logic. I'm not sure what you mean by \"checks for 'type'\". If you mean cases where you use `instanceof()`, the wrapper types are straight subclasses of the primitive type so will pass this check without issue. I might also have to apply some more aggressive patching to the mzXML parser which I wrote quick and dirty, didn't have an up-to-date xsd for reference, and doesn't have semantic data regarding units and so I probably blindly convert times to seconds or crash and burn when input doesn't conform to my expectations.\n\nHere are the wrapper classes:\n```python\nclass unitint(int):\n    def __new__(cls, value, unit_metadata):\n        inst = super(unitint, cls).__new__(cls, value)\n        inst.unit_info = unit_metadata\n        return inst\n\n    def __repr__(self):\n        base = super(unitint, self).__repr__()\n        if self.unit_info:\n            return \"%s %s\" % (base, self.unit_info)\n        else:\n            return base\n\n\nclass unitfloat(float):\n    def __new__(cls, value, unit_metadata):\n        inst = super(unitfloat, cls).__new__(cls, value)\n        inst.unit_info = unit_metadata\n        return inst\n\n    def __repr__(self):\n        base = super(unitfloat, self).__repr__()\n        if self.unit_info:\n            return \"%s %s\" % (base, self.unit_info)\n        else:\n            return base\n\n\nclass unitstr(str):\n    def __new__(cls, value, unit_metadata):\n        inst = super(unitstr, cls).__new__(cls, value)\n        inst.unit_info = unit_metadata\n        return inst\n\n    def __repr__(self):\n        base = super(unitstr, self).__repr__()\n        if self.unit_info:\n            return \"%s %s\" % (base, self.unit_info)\n        else:\n            return base\n```\nThat's all. Then, in the `_handle_param` method, I'd use `unitint` instead of `int` in the types dictionary propagate the unit information as a `dict` or perhaps a more specialized container in the `unit_info` attribute of each instance. If no unit is specified, the `.unit_info` is set to `None` so that if new client code were to check for a unit on something that the input data did not include a unit for, they would check for `unit_info is None` instead of `hasattr(value, 'unit_info')`. I would do the same for `float` and `str`, and because these are straight subclasses, not magical method forwarding wrappers, all type checks and conversions work as normal. `unitstr` still has all of the methods of `str` and \n```\nIn [4]: unitint(5, 'mz')\nOut[4]: 5 mz\n\nIn [5]: x = unitint(5, 'mz')\n\nIn [6]: x.unit_info\nOut[6]: 'mz'\n\nIn [7]: x * 2\nOut[7]: 10\n\nIn [8]: x2 = x * 2\n\nIn [9]: x2 \nOut[9]: 10  # Notice unit information has been lost\n\nIn [10]: isinstance(x, int)\nOut[10]: True\n\nIn [11]: import numpy as np\n\nIn [12]: np.array([x])\nOut[12]: array([5])\n\nIn [13]: np.array([x]).dtype\nOut[13]: dtype('int32')  # Notice unit information has been lost and implicitly converted into a native int\n```\nThe only downside is that the metadata is lost if any in-place operations are used, so `+=` would strip the unit metadata, and it does not propagate through copy-making operators like `*`. These would require rewriting all the operators accordingly, and is not worth it if its not needed. While this method works for scalars, it explicitly ignores things like units on array-valued fields like those in mzML. There are cases where these would need to be handled intelligently, like `chromatogram` tags have `<cvParam cvRef=\"MS\" accession=\"MS:1000595\" name=\"time array\" value=\"\" unitCvRef=\"UO\" unitAccession=\"UO:0000031\" unitName=\"minute\"/>` where this unit could just as easily be seconds, but that would mean subclassing `ndarray`, which I don't know well enough to say how it will behave across the whole PyData ecosystem at the Python and C level.\n\nOne reason why this should be done as opposed to choosing a \"sane default\" unit for each parameter is that it may not be possible to make the \"right choice\" in every instance, or it may not be possible to convert units. For example in mzIdentML, mass accuracy parameters for `<ParentTolerance>` and `<FragmentTolerance>` are encoded with a cvParam whose value is the magnitude of the tolerance and the unit could be \"daltons\" or \"parts per million\", for which there is no 1:1 mapping since \"dalton\" mass accuracy is fixed while \"parts per million\" mass accuracy is a dynamic quantity.\n\n```xml\n<!-- with Dalton -->\n<ParentTolerance>\n  <cvParam accession=\"MS:1001412\" name=\"search tolerance plus value\" value=\"1.5\" cvRef=\"PSI-MS\" unitAccession=\"UO:0000221\" unitName=\"dalton\" unitCvRef=\"UO\"/>\n  <cvParam accession=\"MS:1001413\" name=\"search tolerance minus value\" value=\"1.5\" cvRef=\"PSI-MS\" unitAccession=\"UO:0000221\" unitName=\"dalton\" unitCvRef=\"UO\"/>\n</ParentTolerance>\n<!-- with PPM -->\n<ParentTolerance>\n  <cvParam accession=\"MS:1001412\" cvRef=\"PSI-MS\" unitCvRef=\"UO\" unitName=\"parts per million\" unitAccession=\"UO:0000169\" value=\"10.0\" name=\"search tolerance plus value\"/>\n  <cvParam accession=\"MS:1001413\" cvRef=\"PSI-MS\" unitCvRef=\"UO\" unitName=\"parts per million\" unitAccession=\"UO:0000169\" value=\"10.0\" name=\"search tolerance minus value\"/>\n</ParentTolerance>\n```\nAdmittedly, cases like this one are uncommon, and the majority of the units could be safely ignored. There are probably more than 10 MB of dead weight in a single 1 hour gradient mzML file dedicated to noting that a quantity has units \"m/z\" or \"number of detector counts\" for intensities.\n\nAlso admittedly, I found myself thinking about this only after I got back to writing an mzML serializer. Ideally, I'd read values in from one mzML file, apply transformations like smoothing, centroiding, deisotope/charge state deconvolute, and then write directly out to a new (smaller) mzML file. I realized that once units were stripped, I had to hard code them back in. If you'd accept the pull request when the serializer library is finished, these unit wrappers would hook into the 'Units' ontology that PSI-MS uses to retrieve more metadata. The working copy for that is hosted separately while I work on it: [https://github.com/mobiusklein/psims](https://github.com/mobiusklein/psims)", "markup": "markdown", "html": "<p>The functionality I intend to add is just using a wrapper type instead of a straight primitive type for storing the value of unit-annotated cvParams. Unit conversion is something that can be left to the application logic. I'm not sure what you mean by \"checks for 'type'\". If you mean cases where you use <code>instanceof()</code>, the wrapper types are straight subclasses of the primitive type so will pass this check without issue. I might also have to apply some more aggressive patching to the mzXML parser which I wrote quick and dirty, didn't have an up-to-date xsd for reference, and doesn't have semantic data regarding units and so I probably blindly convert times to seconds or crash and burn when input doesn't conform to my expectations.</p>\n<p>Here are the wrapper classes:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">unitint</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">unit_metadata</span><span class=\"p\">):</span>\n        <span class=\"n\">inst</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitint</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">unit_info</span> <span class=\"o\">=</span> <span class=\"n\">unit_metadata</span>\n        <span class=\"k\">return</span> <span class=\"n\">inst</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitint</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__repr__</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"s2\">&quot;</span><span class=\"si\">%s</span><span class=\"s2\"> </span><span class=\"si\">%s</span><span class=\"s2\">&quot;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">base</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">unitfloat</span><span class=\"p\">(</span><span class=\"nb\">float</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">unit_metadata</span><span class=\"p\">):</span>\n        <span class=\"n\">inst</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitfloat</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">unit_info</span> <span class=\"o\">=</span> <span class=\"n\">unit_metadata</span>\n        <span class=\"k\">return</span> <span class=\"n\">inst</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitfloat</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__repr__</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"s2\">&quot;</span><span class=\"si\">%s</span><span class=\"s2\"> </span><span class=\"si\">%s</span><span class=\"s2\">&quot;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">base</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">unitstr</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">unit_metadata</span><span class=\"p\">):</span>\n        <span class=\"n\">inst</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitstr</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">unit_info</span> <span class=\"o\">=</span> <span class=\"n\">unit_metadata</span>\n        <span class=\"k\">return</span> <span class=\"n\">inst</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitstr</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__repr__</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"s2\">&quot;</span><span class=\"si\">%s</span><span class=\"s2\"> </span><span class=\"si\">%s</span><span class=\"s2\">&quot;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">base</span>\n</pre></div>\n\n\n<p>That's all. Then, in the <code>_handle_param</code> method, I'd use <code>unitint</code> instead of <code>int</code> in the types dictionary propagate the unit information as a <code>dict</code> or perhaps a more specialized container in the <code>unit_info</code> attribute of each instance. If no unit is specified, the <code>.unit_info</code> is set to <code>None</code> so that if new client code were to check for a unit on something that the input data did not include a unit for, they would check for <code>unit_info is None</code> instead of <code>hasattr(value, 'unit_info')</code>. I would do the same for <code>float</code> and <code>str</code>, and because these are straight subclasses, not magical method forwarding wrappers, all type checks and conversions work as normal. <code>unitstr</code> still has all of the methods of <code>str</code> and </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]:</span> <span class=\"n\">unitint</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">&#39;mz&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]:</span> <span class=\"mi\">5</span> <span class=\"n\">mz</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">]:</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">unitint</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">&#39;mz&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">]:</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">unit_info</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">]:</span> <span class=\"s1\">&#39;mz&#39;</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">]:</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">]:</span> <span class=\"mi\">10</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">]:</span> <span class=\"n\">x2</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">9</span><span class=\"p\">]:</span> <span class=\"n\">x2</span> \n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">9</span><span class=\"p\">]:</span> <span class=\"mi\">10</span>  <span class=\"c1\"># Notice unit information has been lost</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">]:</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">)</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">]:</span> <span class=\"bp\">True</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">11</span><span class=\"p\">]:</span> <span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">12</span><span class=\"p\">]:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"kp\">array</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">])</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">12</span><span class=\"p\">]:</span> <span class=\"kp\">array</span><span class=\"p\">([</span><span class=\"mi\">5</span><span class=\"p\">])</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">13</span><span class=\"p\">]:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"kp\">array</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"kp\">dtype</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">13</span><span class=\"p\">]:</span> <span class=\"kp\">dtype</span><span class=\"p\">(</span><span class=\"s1\">&#39;int32&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># Notice unit information has been lost and implicitly converted into a native int</span>\n</pre></div>\n\n\n<p>The only downside is that the metadata is lost if any in-place operations are used, so <code>+=</code> would strip the unit metadata, and it does not propagate through copy-making operators like <code>*</code>. These would require rewriting all the operators accordingly, and is not worth it if its not needed. While this method works for scalars, it explicitly ignores things like units on array-valued fields like those in mzML. There are cases where these would need to be handled intelligently, like <code>chromatogram</code> tags have <code>&lt;cvParam cvRef=\"MS\" accession=\"MS:1000595\" name=\"time array\" value=\"\" unitCvRef=\"UO\" unitAccession=\"UO:0000031\" unitName=\"minute\"/&gt;</code> where this unit could just as easily be seconds, but that would mean subclassing <code>ndarray</code>, which I don't know well enough to say how it will behave across the whole PyData ecosystem at the Python and C level.</p>\n<p>One reason why this should be done as opposed to choosing a \"sane default\" unit for each parameter is that it may not be possible to make the \"right choice\" in every instance, or it may not be possible to convert units. For example in mzIdentML, mass accuracy parameters for <code>&lt;ParentTolerance&gt;</code> and <code>&lt;FragmentTolerance&gt;</code> are encoded with a cvParam whose value is the magnitude of the tolerance and the unit could be \"daltons\" or \"parts per million\", for which there is no 1:1 mapping since \"dalton\" mass accuracy is fixed while \"parts per million\" mass accuracy is a dynamic quantity.</p>\n<div class=\"codehilite language-xml\"><pre><span></span><span class=\"c\">&lt;!-- with Dalton --&gt;</span>\n<span class=\"nt\">&lt;ParentTolerance&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1001412&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;search tolerance plus value&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;1.5&quot;</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;PSI-MS&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;UO:0000221&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;dalton&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;UO&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1001413&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;search tolerance minus value&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;1.5&quot;</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;PSI-MS&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;UO:0000221&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;dalton&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;UO&quot;</span><span class=\"nt\">/&gt;</span>\n<span class=\"nt\">&lt;/ParentTolerance&gt;</span>\n<span class=\"c\">&lt;!-- with PPM --&gt;</span>\n<span class=\"nt\">&lt;ParentTolerance&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1001412&quot;</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;PSI-MS&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;UO&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;parts per million&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;UO:0000169&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;10.0&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;search tolerance plus value&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1001413&quot;</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;PSI-MS&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;UO&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;parts per million&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;UO:0000169&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;10.0&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;search tolerance minus value&quot;</span><span class=\"nt\">/&gt;</span>\n<span class=\"nt\">&lt;/ParentTolerance&gt;</span>\n</pre></div>\n\n\n<p>Admittedly, cases like this one are uncommon, and the majority of the units could be safely ignored. There are probably more than 10 MB of dead weight in a single 1 hour gradient mzML file dedicated to noting that a quantity has units \"m/z\" or \"number of detector counts\" for intensities.</p>\n<p>Also admittedly, I found myself thinking about this only after I got back to writing an mzML serializer. Ideally, I'd read values in from one mzML file, apply transformations like smoothing, centroiding, deisotope/charge state deconvolute, and then write directly out to a new (smaller) mzML file. I realized that once units were stripped, I had to hard code them back in. If you'd accept the pull request when the serializer library is finished, these unit wrappers would hook into the 'Units' ontology that PSI-MS uses to retrieve more metadata. The working copy for that is hosted separately while I work on it: <a data-is-external-link=\"true\" href=\"https://github.com/mobiusklein/psims\" rel=\"nofollow\">https://github.com/mobiusklein/psims</a></p>", "type": "rendered"}, "created_on": "2017-01-05T05:01:10.743532+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2017-01-05T05:02:16.873255+00:00", "type": "issue_comment", "id": 33370570}