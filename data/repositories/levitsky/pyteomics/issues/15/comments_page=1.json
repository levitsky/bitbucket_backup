{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15/comments/33366944.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/15#comment-33366944"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "cvParam Unit Awareness"}, "content": {"raw": "That would be a great addition, but sounds like a lot of work. Wouldn't it be easier to convert the values to some standard units instead (minutes to seconds, etc.)?\nBecause in my mind the most common reason why we need this is that we often compare values between different files, and they may be in different units. Simple conversion without any subclassing would solve this. Do you have other use cases in mind?\nAlso, what happens with the current checks for `'type'`?\nFinally, what kind of functionality do you intend to add? Is it only unit metadata attributes or do you mean to write converters, too?", "markup": "markdown", "html": "<p>That would be a great addition, but sounds like a lot of work. Wouldn't it be easier to convert the values to some standard units instead (minutes to seconds, etc.)?\nBecause in my mind the most common reason why we need this is that we often compare values between different files, and they may be in different units. Simple conversion without any subclassing would solve this. Do you have other use cases in mind?\nAlso, what happens with the current checks for <code>'type'</code>?\nFinally, what kind of functionality do you intend to add? Is it only unit metadata attributes or do you mean to write converters, too?</p>", "type": "rendered"}, "created_on": "2017-01-04T22:05:23.195645+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": null, "type": "issue_comment", "id": 33366944}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15/comments/33370570.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/15#comment-33370570"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "cvParam Unit Awareness"}, "content": {"raw": "The functionality I intend to add is just using a wrapper type instead of a straight primitive type for storing the value of unit-annotated cvParams. Unit conversion is something that can be left to the application logic. I'm not sure what you mean by \"checks for 'type'\". If you mean cases where you use `instanceof()`, the wrapper types are straight subclasses of the primitive type so will pass this check without issue. I might also have to apply some more aggressive patching to the mzXML parser which I wrote quick and dirty, didn't have an up-to-date xsd for reference, and doesn't have semantic data regarding units and so I probably blindly convert times to seconds or crash and burn when input doesn't conform to my expectations.\n\nHere are the wrapper classes:\n```python\nclass unitint(int):\n    def __new__(cls, value, unit_metadata):\n        inst = super(unitint, cls).__new__(cls, value)\n        inst.unit_info = unit_metadata\n        return inst\n\n    def __repr__(self):\n        base = super(unitint, self).__repr__()\n        if self.unit_info:\n            return \"%s %s\" % (base, self.unit_info)\n        else:\n            return base\n\n\nclass unitfloat(float):\n    def __new__(cls, value, unit_metadata):\n        inst = super(unitfloat, cls).__new__(cls, value)\n        inst.unit_info = unit_metadata\n        return inst\n\n    def __repr__(self):\n        base = super(unitfloat, self).__repr__()\n        if self.unit_info:\n            return \"%s %s\" % (base, self.unit_info)\n        else:\n            return base\n\n\nclass unitstr(str):\n    def __new__(cls, value, unit_metadata):\n        inst = super(unitstr, cls).__new__(cls, value)\n        inst.unit_info = unit_metadata\n        return inst\n\n    def __repr__(self):\n        base = super(unitstr, self).__repr__()\n        if self.unit_info:\n            return \"%s %s\" % (base, self.unit_info)\n        else:\n            return base\n```\nThat's all. Then, in the `_handle_param` method, I'd use `unitint` instead of `int` in the types dictionary propagate the unit information as a `dict` or perhaps a more specialized container in the `unit_info` attribute of each instance. If no unit is specified, the `.unit_info` is set to `None` so that if new client code were to check for a unit on something that the input data did not include a unit for, they would check for `unit_info is None` instead of `hasattr(value, 'unit_info')`. I would do the same for `float` and `str`, and because these are straight subclasses, not magical method forwarding wrappers, all type checks and conversions work as normal. `unitstr` still has all of the methods of `str` and \n```\nIn [4]: unitint(5, 'mz')\nOut[4]: 5 mz\n\nIn [5]: x = unitint(5, 'mz')\n\nIn [6]: x.unit_info\nOut[6]: 'mz'\n\nIn [7]: x * 2\nOut[7]: 10\n\nIn [8]: x2 = x * 2\n\nIn [9]: x2 \nOut[9]: 10  # Notice unit information has been lost\n\nIn [10]: isinstance(x, int)\nOut[10]: True\n\nIn [11]: import numpy as np\n\nIn [12]: np.array([x])\nOut[12]: array([5])\n\nIn [13]: np.array([x]).dtype\nOut[13]: dtype('int32')  # Notice unit information has been lost and implicitly converted into a native int\n```\nThe only downside is that the metadata is lost if any in-place operations are used, so `+=` would strip the unit metadata, and it does not propagate through copy-making operators like `*`. These would require rewriting all the operators accordingly, and is not worth it if its not needed. While this method works for scalars, it explicitly ignores things like units on array-valued fields like those in mzML. There are cases where these would need to be handled intelligently, like `chromatogram` tags have `<cvParam cvRef=\"MS\" accession=\"MS:1000595\" name=\"time array\" value=\"\" unitCvRef=\"UO\" unitAccession=\"UO:0000031\" unitName=\"minute\"/>` where this unit could just as easily be seconds, but that would mean subclassing `ndarray`, which I don't know well enough to say how it will behave across the whole PyData ecosystem at the Python and C level.\n\nOne reason why this should be done as opposed to choosing a \"sane default\" unit for each parameter is that it may not be possible to make the \"right choice\" in every instance, or it may not be possible to convert units. For example in mzIdentML, mass accuracy parameters for `<ParentTolerance>` and `<FragmentTolerance>` are encoded with a cvParam whose value is the magnitude of the tolerance and the unit could be \"daltons\" or \"parts per million\", for which there is no 1:1 mapping since \"dalton\" mass accuracy is fixed while \"parts per million\" mass accuracy is a dynamic quantity.\n\n```xml\n<!-- with Dalton -->\n<ParentTolerance>\n  <cvParam accession=\"MS:1001412\" name=\"search tolerance plus value\" value=\"1.5\" cvRef=\"PSI-MS\" unitAccession=\"UO:0000221\" unitName=\"dalton\" unitCvRef=\"UO\"/>\n  <cvParam accession=\"MS:1001413\" name=\"search tolerance minus value\" value=\"1.5\" cvRef=\"PSI-MS\" unitAccession=\"UO:0000221\" unitName=\"dalton\" unitCvRef=\"UO\"/>\n</ParentTolerance>\n<!-- with PPM -->\n<ParentTolerance>\n  <cvParam accession=\"MS:1001412\" cvRef=\"PSI-MS\" unitCvRef=\"UO\" unitName=\"parts per million\" unitAccession=\"UO:0000169\" value=\"10.0\" name=\"search tolerance plus value\"/>\n  <cvParam accession=\"MS:1001413\" cvRef=\"PSI-MS\" unitCvRef=\"UO\" unitName=\"parts per million\" unitAccession=\"UO:0000169\" value=\"10.0\" name=\"search tolerance minus value\"/>\n</ParentTolerance>\n```\nAdmittedly, cases like this one are uncommon, and the majority of the units could be safely ignored. There are probably more than 10 MB of dead weight in a single 1 hour gradient mzML file dedicated to noting that a quantity has units \"m/z\" or \"number of detector counts\" for intensities.\n\nAlso admittedly, I found myself thinking about this only after I got back to writing an mzML serializer. Ideally, I'd read values in from one mzML file, apply transformations like smoothing, centroiding, deisotope/charge state deconvolute, and then write directly out to a new (smaller) mzML file. I realized that once units were stripped, I had to hard code them back in. If you'd accept the pull request when the serializer library is finished, these unit wrappers would hook into the 'Units' ontology that PSI-MS uses to retrieve more metadata. The working copy for that is hosted separately while I work on it: [https://github.com/mobiusklein/psims](https://github.com/mobiusklein/psims)", "markup": "markdown", "html": "<p>The functionality I intend to add is just using a wrapper type instead of a straight primitive type for storing the value of unit-annotated cvParams. Unit conversion is something that can be left to the application logic. I'm not sure what you mean by \"checks for 'type'\". If you mean cases where you use <code>instanceof()</code>, the wrapper types are straight subclasses of the primitive type so will pass this check without issue. I might also have to apply some more aggressive patching to the mzXML parser which I wrote quick and dirty, didn't have an up-to-date xsd for reference, and doesn't have semantic data regarding units and so I probably blindly convert times to seconds or crash and burn when input doesn't conform to my expectations.</p>\n<p>Here are the wrapper classes:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">unitint</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">unit_metadata</span><span class=\"p\">):</span>\n        <span class=\"n\">inst</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitint</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">unit_info</span> <span class=\"o\">=</span> <span class=\"n\">unit_metadata</span>\n        <span class=\"k\">return</span> <span class=\"n\">inst</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitint</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__repr__</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"s2\">&quot;</span><span class=\"si\">%s</span><span class=\"s2\"> </span><span class=\"si\">%s</span><span class=\"s2\">&quot;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">base</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">unitfloat</span><span class=\"p\">(</span><span class=\"nb\">float</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">unit_metadata</span><span class=\"p\">):</span>\n        <span class=\"n\">inst</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitfloat</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">unit_info</span> <span class=\"o\">=</span> <span class=\"n\">unit_metadata</span>\n        <span class=\"k\">return</span> <span class=\"n\">inst</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitfloat</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__repr__</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"s2\">&quot;</span><span class=\"si\">%s</span><span class=\"s2\"> </span><span class=\"si\">%s</span><span class=\"s2\">&quot;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">base</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">unitstr</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">unit_metadata</span><span class=\"p\">):</span>\n        <span class=\"n\">inst</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitstr</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">unit_info</span> <span class=\"o\">=</span> <span class=\"n\">unit_metadata</span>\n        <span class=\"k\">return</span> <span class=\"n\">inst</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">unitstr</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__repr__</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"s2\">&quot;</span><span class=\"si\">%s</span><span class=\"s2\"> </span><span class=\"si\">%s</span><span class=\"s2\">&quot;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">unit_info</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">base</span>\n</pre></div>\n\n\n<p>That's all. Then, in the <code>_handle_param</code> method, I'd use <code>unitint</code> instead of <code>int</code> in the types dictionary propagate the unit information as a <code>dict</code> or perhaps a more specialized container in the <code>unit_info</code> attribute of each instance. If no unit is specified, the <code>.unit_info</code> is set to <code>None</code> so that if new client code were to check for a unit on something that the input data did not include a unit for, they would check for <code>unit_info is None</code> instead of <code>hasattr(value, 'unit_info')</code>. I would do the same for <code>float</code> and <code>str</code>, and because these are straight subclasses, not magical method forwarding wrappers, all type checks and conversions work as normal. <code>unitstr</code> still has all of the methods of <code>str</code> and </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]:</span> <span class=\"n\">unitint</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">&#39;mz&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]:</span> <span class=\"mi\">5</span> <span class=\"n\">mz</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">]:</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">unitint</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">&#39;mz&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">]:</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">unit_info</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">]:</span> <span class=\"s1\">&#39;mz&#39;</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">]:</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">]:</span> <span class=\"mi\">10</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">]:</span> <span class=\"n\">x2</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">9</span><span class=\"p\">]:</span> <span class=\"n\">x2</span> \n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">9</span><span class=\"p\">]:</span> <span class=\"mi\">10</span>  <span class=\"c1\"># Notice unit information has been lost</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">]:</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">)</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">]:</span> <span class=\"bp\">True</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">11</span><span class=\"p\">]:</span> <span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">12</span><span class=\"p\">]:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"kp\">array</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">])</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">12</span><span class=\"p\">]:</span> <span class=\"kp\">array</span><span class=\"p\">([</span><span class=\"mi\">5</span><span class=\"p\">])</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">13</span><span class=\"p\">]:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"kp\">array</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"kp\">dtype</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">13</span><span class=\"p\">]:</span> <span class=\"kp\">dtype</span><span class=\"p\">(</span><span class=\"s1\">&#39;int32&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># Notice unit information has been lost and implicitly converted into a native int</span>\n</pre></div>\n\n\n<p>The only downside is that the metadata is lost if any in-place operations are used, so <code>+=</code> would strip the unit metadata, and it does not propagate through copy-making operators like <code>*</code>. These would require rewriting all the operators accordingly, and is not worth it if its not needed. While this method works for scalars, it explicitly ignores things like units on array-valued fields like those in mzML. There are cases where these would need to be handled intelligently, like <code>chromatogram</code> tags have <code>&lt;cvParam cvRef=\"MS\" accession=\"MS:1000595\" name=\"time array\" value=\"\" unitCvRef=\"UO\" unitAccession=\"UO:0000031\" unitName=\"minute\"/&gt;</code> where this unit could just as easily be seconds, but that would mean subclassing <code>ndarray</code>, which I don't know well enough to say how it will behave across the whole PyData ecosystem at the Python and C level.</p>\n<p>One reason why this should be done as opposed to choosing a \"sane default\" unit for each parameter is that it may not be possible to make the \"right choice\" in every instance, or it may not be possible to convert units. For example in mzIdentML, mass accuracy parameters for <code>&lt;ParentTolerance&gt;</code> and <code>&lt;FragmentTolerance&gt;</code> are encoded with a cvParam whose value is the magnitude of the tolerance and the unit could be \"daltons\" or \"parts per million\", for which there is no 1:1 mapping since \"dalton\" mass accuracy is fixed while \"parts per million\" mass accuracy is a dynamic quantity.</p>\n<div class=\"codehilite language-xml\"><pre><span></span><span class=\"c\">&lt;!-- with Dalton --&gt;</span>\n<span class=\"nt\">&lt;ParentTolerance&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1001412&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;search tolerance plus value&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;1.5&quot;</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;PSI-MS&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;UO:0000221&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;dalton&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;UO&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1001413&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;search tolerance minus value&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;1.5&quot;</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;PSI-MS&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;UO:0000221&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;dalton&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;UO&quot;</span><span class=\"nt\">/&gt;</span>\n<span class=\"nt\">&lt;/ParentTolerance&gt;</span>\n<span class=\"c\">&lt;!-- with PPM --&gt;</span>\n<span class=\"nt\">&lt;ParentTolerance&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1001412&quot;</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;PSI-MS&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;UO&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;parts per million&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;UO:0000169&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;10.0&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;search tolerance plus value&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1001413&quot;</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;PSI-MS&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;UO&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;parts per million&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;UO:0000169&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;10.0&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;search tolerance minus value&quot;</span><span class=\"nt\">/&gt;</span>\n<span class=\"nt\">&lt;/ParentTolerance&gt;</span>\n</pre></div>\n\n\n<p>Admittedly, cases like this one are uncommon, and the majority of the units could be safely ignored. There are probably more than 10 MB of dead weight in a single 1 hour gradient mzML file dedicated to noting that a quantity has units \"m/z\" or \"number of detector counts\" for intensities.</p>\n<p>Also admittedly, I found myself thinking about this only after I got back to writing an mzML serializer. Ideally, I'd read values in from one mzML file, apply transformations like smoothing, centroiding, deisotope/charge state deconvolute, and then write directly out to a new (smaller) mzML file. I realized that once units were stripped, I had to hard code them back in. If you'd accept the pull request when the serializer library is finished, these unit wrappers would hook into the 'Units' ontology that PSI-MS uses to retrieve more metadata. The working copy for that is hosted separately while I work on it: <a data-is-external-link=\"true\" href=\"https://github.com/mobiusklein/psims\" rel=\"nofollow\">https://github.com/mobiusklein/psims</a></p>", "type": "rendered"}, "created_on": "2017-01-05T05:01:10.743532+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": "2017-01-05T05:02:16.873255+00:00", "type": "issue_comment", "id": 33370570}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15/comments/33376540.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/15#comment-33376540"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "cvParam Unit Awareness"}, "content": {"raw": "By current checks for 'type' I meant the 'type' attribute checking in the current code of `_handle_param`. You're saying we should look at unitCVRef, unitAccession, and unitName instead?\nWhat happens with the 'type' info? *(oh, wait, is \"type\" for `userParam` and \"unitName\" for `cvParam`? Seems like it in my test files)*\n\nAlso, there is much more code for conversion of non-cvparam stuff using `_schema_info`, which also uses the same kind of checks for \"type\" attribute (although on the schema tree elements). I remember having to edit `_schema_defaults` manually for some elements. Do we want to keep these mechanisms separate?\n\nIn the end there is no difference between values from cvParam tags and other elements in the final dict. Do we want to keep everything as is except for `_handle_param` and have both regular floats and unitfloats mixed in the output? I'm just asking because these things have always seemed quite abstract for me, and I never really got into the philosophy behind the structure when I was writing the parsers (which you helped re-write at least once already), so I'm not sure what would be the \"proper\" way. I see that your proposal doesn't break anything, though, so I have no reasons to oppose it.", "markup": "markdown", "html": "<p>By current checks for 'type' I meant the 'type' attribute checking in the current code of <code>_handle_param</code>. You're saying we should look at unitCVRef, unitAccession, and unitName instead?\nWhat happens with the 'type' info? <em>(oh, wait, is \"type\" for <code>userParam</code> and \"unitName\" for <code>cvParam</code>? Seems like it in my test files)</em></p>\n<p>Also, there is much more code for conversion of non-cvparam stuff using <code>_schema_info</code>, which also uses the same kind of checks for \"type\" attribute (although on the schema tree elements). I remember having to edit <code>_schema_defaults</code> manually for some elements. Do we want to keep these mechanisms separate?</p>\n<p>In the end there is no difference between values from cvParam tags and other elements in the final dict. Do we want to keep everything as is except for <code>_handle_param</code> and have both regular floats and unitfloats mixed in the output? I'm just asking because these things have always seemed quite abstract for me, and I never really got into the philosophy behind the structure when I was writing the parsers (which you helped re-write at least once already), so I'm not sure what would be the \"proper\" way. I see that your proposal doesn't break anything, though, so I have no reasons to oppose it.</p>", "type": "rendered"}, "created_on": "2017-01-05T10:26:53.771015+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": null, "type": "issue_comment", "id": 33376540}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15/comments/33389083.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/15#comment-33389083"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "cvParam Unit Awareness"}, "content": {"raw": "Schema value types, taken from the document XSDs, are abstract datatypes in their own right. Some are directly mappable to primitive types, as we do. Others might be compound datatypes, which are made up of compositions of elements. They might imply units, but they *must* be consistent or somehow encoded by another property of the document. For PSI XML, this kind of design was superseded by these semantic parameters. This is *not* the case for `mzXML` where they do things like encode time in a string with the prefix \"PT\" and suffix \"S\" (for seconds) wrapped around a floating point number, where the XSD description of these attributes is \"time duration type\". That means that documents like that require special handling. I might address that for mzXML if I can find full documentation. Doing that generally is beyond the scope of the work I propose to do. \n\nAs for mixing unit- and plain value types, it would make a cleaner API if everything were consistent. That could be handled in `xml.XMLValueConverter` where `unit_info` is just set to `None` since units cannot be inferred automatically. I'm tempted to ignore this case because \"the user will know when to expect a unit and when not to\", but I think that because I've had to study the schemas for the document types I use, and if I were to be exposed to a new document type tomorrow, without documentation about different values, I'd probably want to not guess at whether a value had a unit.\n\n`userParam`'s `type` field is an inline XSD specification for that tag's value, since by definition, `userParam`s cannot be pre-specified.\n```xml\n<userParam name=\"[Thermo Trailer Extra]Monoisotopic M/Z:\" value=\"810.41522216796875\" type=\"xsd:float\"/>\n```\n`cvParam`'s identity implies the data type in its CV definition:\n\n```text\n[Term]\nid: MS:1000041\nname: charge state\ndef: \"The charge state of the ion, single or multiple and positive or negatively charged.\" [PSI:MS]\nsynonym: \"z\" EXACT []\nxref: value-type:xsd\\:int \"The allowed value-type for this CV term.\" # <-- data type\nis_a: MS:1000455 ! ion selection attribute\n```\nAs it happens, we don't use this information since the parsers don't access the CV to resolve terms, so we always make them `float` if numeric or `str` otherwise (snippet of `_handle_param`):\n```python\n if 'value' in element.attrib:\n            try:\n                if element.attrib.get('type') in types:  # If the type is specified, as in userParam\n                    value = types[element.attrib['type']](element.attrib['value'])\n                else: # Otherwise treat it like a float\n                    value = float(element.attrib['value'])\n            except ValueError:\n                value = element.attrib['value']  # Handle the case where it cannot be converted into a numeric value from a string by just leaving it as a string\n            return {element.attrib['name']: value}\n```\n```xml\n<selectedIon>\n  <cvParam cvRef=\"MS\" accession=\"MS:1000744\" name=\"selected ion m/z\" value=\"1061.424072265625\" unitCvRef=\"MS\" unitAccession=\"MS:1000040\" unitName=\"m/z\"/>\n  <cvParam cvRef=\"MS\" accession=\"MS:1000041\" name=\"charge state\" value=\"3\"/> <!-- will be converted to float instead int -->\n  <cvParam cvRef=\"MS\" accession=\"MS:1000042\" name=\"peak intensity\" value=\"7.069659375e05\" unitCvRef=\"MS\" unitAccession=\"MS:1000131\" unitName=\"number of detector counts\"/>\n</selectedIon>\n```", "markup": "markdown", "html": "<p>Schema value types, taken from the document XSDs, are abstract datatypes in their own right. Some are directly mappable to primitive types, as we do. Others might be compound datatypes, which are made up of compositions of elements. They might imply units, but they <em>must</em> be consistent or somehow encoded by another property of the document. For PSI XML, this kind of design was superseded by these semantic parameters. This is <em>not</em> the case for <code>mzXML</code> where they do things like encode time in a string with the prefix \"PT\" and suffix \"S\" (for seconds) wrapped around a floating point number, where the XSD description of these attributes is \"time duration type\". That means that documents like that require special handling. I might address that for mzXML if I can find full documentation. Doing that generally is beyond the scope of the work I propose to do. </p>\n<p>As for mixing unit- and plain value types, it would make a cleaner API if everything were consistent. That could be handled in <code>xml.XMLValueConverter</code> where <code>unit_info</code> is just set to <code>None</code> since units cannot be inferred automatically. I'm tempted to ignore this case because \"the user will know when to expect a unit and when not to\", but I think that because I've had to study the schemas for the document types I use, and if I were to be exposed to a new document type tomorrow, without documentation about different values, I'd probably want to not guess at whether a value had a unit.</p>\n<p><code>userParam</code>'s <code>type</code> field is an inline XSD specification for that tag's value, since by definition, <code>userParam</code>s cannot be pre-specified.</p>\n<div class=\"codehilite language-xml\"><pre><span></span><span class=\"nt\">&lt;userParam</span> <span class=\"na\">name=</span><span class=\"s\">&quot;[Thermo Trailer Extra]Monoisotopic M/Z:&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;810.41522216796875&quot;</span> <span class=\"na\">type=</span><span class=\"s\">&quot;xsd:float&quot;</span><span class=\"nt\">/&gt;</span>\n</pre></div>\n\n\n<p><code>cvParam</code>'s identity implies the data type in its CV definition:</p>\n<div class=\"codehilite language-text\"><pre><span></span>[Term]\nid: MS:1000041\nname: charge state\ndef: &quot;The charge state of the ion, single or multiple and positive or negatively charged.&quot; [PSI:MS]\nsynonym: &quot;z&quot; EXACT []\nxref: value-type:xsd\\:int &quot;The allowed value-type for this CV term.&quot; # &lt;-- data type\nis_a: MS:1000455 ! ion selection attribute\n</pre></div>\n\n\n<p>As it happens, we don't use this information since the parsers don't access the CV to resolve terms, so we always make them <code>float</code> if numeric or <code>str</code> otherwise (snippet of <code>_handle_param</code>):</p>\n<div class=\"codehilite language-python\"><pre><span></span> <span class=\"k\">if</span> <span class=\"s1\">&#39;value&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;type&#39;</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">:</span>  <span class=\"c1\"># If the type is specified, as in userParam</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">types</span><span class=\"p\">[</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;type&#39;</span><span class=\"p\">]](</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">])</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span> <span class=\"c1\"># Otherwise treat it like a float</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">])</span>\n            <span class=\"k\">except</span> <span class=\"ne\">ValueError</span><span class=\"p\">:</span>\n                <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">]</span>  <span class=\"c1\"># Handle the case where it cannot be converted into a numeric value from a string by just leaving it as a string</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;name&#39;</span><span class=\"p\">]:</span> <span class=\"n\">value</span><span class=\"p\">}</span>\n</pre></div>\n\n\n<div class=\"codehilite language-xml\"><pre><span></span><span class=\"nt\">&lt;selectedIon&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1000744&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;selected ion m/z&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;1061.424072265625&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;MS:1000040&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;m/z&quot;</span><span class=\"nt\">/&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1000041&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;charge state&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;3&quot;</span><span class=\"nt\">/&gt;</span> <span class=\"c\">&lt;!-- will be converted to float instead int --&gt;</span>\n  <span class=\"nt\">&lt;cvParam</span> <span class=\"na\">cvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">accession=</span><span class=\"s\">&quot;MS:1000042&quot;</span> <span class=\"na\">name=</span><span class=\"s\">&quot;peak intensity&quot;</span> <span class=\"na\">value=</span><span class=\"s\">&quot;7.069659375e05&quot;</span> <span class=\"na\">unitCvRef=</span><span class=\"s\">&quot;MS&quot;</span> <span class=\"na\">unitAccession=</span><span class=\"s\">&quot;MS:1000131&quot;</span> <span class=\"na\">unitName=</span><span class=\"s\">&quot;number of detector counts&quot;</span><span class=\"nt\">/&gt;</span>\n<span class=\"nt\">&lt;/selectedIon&gt;</span>\n</pre></div>", "type": "rendered"}, "created_on": "2017-01-05T18:01:00.751871+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": null, "type": "issue_comment", "id": 33389083}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15/comments/33390281.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/15#comment-33390281"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "cvParam Unit Awareness"}, "content": {"raw": "Implementation at [#!/levitsky/pyteomics/pull-requests/8](#!/levitsky/pyteomics/pull-requests/8)", "markup": "markdown", "html": "<p>Implementation at <a data-is-external-link=\"true\" href=\"#!/levitsky/pyteomics/pull-requests/8\" rel=\"nofollow\">#!/levitsky/pyteomics/pull-requests/8</a></p>", "type": "rendered"}, "created_on": "2017-01-05T18:52:07.754265+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": null, "type": "issue_comment", "id": 33390281}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15/comments/33598758.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/15#comment-33598758"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "cvParam Unit Awareness"}, "content": {"raw": "PR merged.", "markup": "markdown", "html": "<p>PR merged.</p>", "type": "rendered"}, "created_on": "2017-01-12T13:08:56.116560+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": null, "type": "issue_comment", "id": 33598758}], "page": 1, "size": 6}