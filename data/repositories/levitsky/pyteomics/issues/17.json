{"priority": "minor", "kind": "proposal", "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "links": {"attachments": {"href": "data/repositories/levitsky/pyteomics/issues/17/attachments_page=1.json"}, "self": {"href": "data/repositories/levitsky/pyteomics/issues/17.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/levitsky/pyteomics/issues/17/watch"}, "comments": {"href": "data/repositories/levitsky/pyteomics/issues/17/comments_page=1.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/17/pre-indexing-xml-files"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/levitsky/pyteomics/issues/17/vote"}}, "reporter": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "title": "Pre-indexing XML Files", "component": null, "votes": 0, "watches": 1, "content": {"raw": "When using the IndexedXML-derived parsers, every time a reader is instantiated, the whole file must be read over to build the byte offset index in memory, as we don't try or trust the tail index. On very large files, this scanning process can take between 5 and 20 seconds. This may just be inconvenient at times, but it also means that parallelizing operations must have a much greater work savings in order to be worthwhile. I've implemented a suite of methods to save the byte offset index to a file and query that file before performing the whole file scan.  This means that after pre-indexing the file, new readers are immediately ready to use and do not incur that startup cost. If the index file is missing, it falls back to the normal behavior of scanning the file.\r\n\r\n```python\r\n\r\ndef save_byte_index(index, fp):\r\n    \"\"\"Write the byte offset index to the provided\r\n    file\r\n\r\n    Parameters\r\n    ----------\r\n    index : ByteEncodingOrderedDict\r\n        The byte offset index to be saved\r\n    fp : file\r\n        The file to write the index to\r\n\r\n    Returns\r\n    -------\r\n    file\r\n    \"\"\"\r\n    encoded_index = dict()\r\n    for key, offset in index.items():\r\n        encoded_index[key.decode(\"utf8\")] = offset\r\n    json.dump(encoded_index, fp)\r\n    return fp\r\n\r\n\r\ndef load_byte_index(fp):\r\n    \"\"\"Read a byte offset index from a file\r\n\r\n    Parameters\r\n    ----------\r\n    fp : file\r\n        The file to read the index from\r\n\r\n    Returns\r\n    -------\r\n    ByteEncodingOrderedDict\r\n    \"\"\"\r\n    data = json.load(fp)\r\n    index = xml.ByteEncodingOrderedDict()\r\n    for key, value in sorted(data.items(), key=lambda x: x[1]):\r\n        index[key] = value\r\n    return index\r\n\r\n\r\nclass PrebuiltOffsetIndex(xml.FlatTagSpecificXMLByteIndex):\r\n    \"\"\"An Offset Index class which just holds offsets\r\n    and performs no extra scanning effort.\r\n\r\n    Attributes\r\n    ----------\r\n    offsets : ByteEncodingOrderedDict\r\n    \"\"\"\r\n\r\n    def __init__(self, offsets):\r\n        self.offsets = offsets\r\n\r\n\r\nclass IndexSavingXML(xml.IndexedXML):\r\n    \"\"\"An extension to the IndexedXML type which\r\n    adds facilities to read and write the byte offset\r\n    index externally.\r\n    \"\"\"\r\n\r\n    _save_byte_index_to_file = staticmethod(save_byte_index)\r\n    _load_byte_index_from_file = staticmethod(load_byte_index)\r\n\r\n    @property\r\n    def _byte_offset_filename(self):\r\n        path = self._source.name\r\n        byte_offset_filename = os.path.splitext(path)[0] + '-byte-offsets.json'\r\n        return byte_offset_filename\r\n\r\n    def _check_has_byte_offset_file(self):\r\n        path = self._byte_offset_filename\r\n        return os.path.exists(path)\r\n\r\n    def _read_byte_offsets(self):\r\n        with open(self._byte_offset_filename, 'r') as f:\r\n            index = PrebuiltOffsetIndex(self._load_byte_index_from_file(f))\r\n            self._offset_index = index\r\n\r\n    def _write_byte_offsets(self):\r\n        with open(self._byte_offset_filename, 'w') as f:\r\n            self._save_byte_index_to_file(self._offset_index, f)\r\n\r\n    @xml._keepstate\r\n    def _build_index(self):\r\n        try:\r\n            self._read_byte_offsets()\r\n        except IOError:\r\n            super(IndexSavingXML, self)._build_index()\r\n\r\n    @classmethod\r\n    def prebuild_byte_offset_file(cls, path):\r\n        inst = cls(path, use_index=True)\r\n        inst._write_byte_offsets()\r\n```\r\n\r\nIf you agree this is a good idea, I'll integrate this into my fork and make `MzML` and `MzXML` descend from this class instead of IndexedXML directly.", "markup": "markdown", "html": "<p>When using the IndexedXML-derived parsers, every time a reader is instantiated, the whole file must be read over to build the byte offset index in memory, as we don't try or trust the tail index. On very large files, this scanning process can take between 5 and 20 seconds. This may just be inconvenient at times, but it also means that parallelizing operations must have a much greater work savings in order to be worthwhile. I've implemented a suite of methods to save the byte offset index to a file and query that file before performing the whole file scan.  This means that after pre-indexing the file, new readers are immediately ready to use and do not incur that startup cost. If the index file is missing, it falls back to the normal behavior of scanning the file.</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">save_byte_index</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">fp</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Write the byte offset index to the provided</span>\n<span class=\"sd\">    file</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    index : ByteEncodingOrderedDict</span>\n<span class=\"sd\">        The byte offset index to be saved</span>\n<span class=\"sd\">    fp : file</span>\n<span class=\"sd\">        The file to write the index to</span>\n\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    file</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">encoded_index</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">offset</span> <span class=\"ow\">in</span> <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n        <span class=\"n\">encoded_index</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">(</span><span class=\"s2\">&quot;utf8&quot;</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"n\">offset</span>\n    <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"n\">encoded_index</span><span class=\"p\">,</span> <span class=\"n\">fp</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">fp</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">load_byte_index</span><span class=\"p\">(</span><span class=\"n\">fp</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Read a byte offset index from a file</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    fp : file</span>\n<span class=\"sd\">        The file to read the index from</span>\n\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    ByteEncodingOrderedDict</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">fp</span><span class=\"p\">)</span>\n    <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">xml</span><span class=\"o\">.</span><span class=\"n\">ByteEncodingOrderedDict</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">(),</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]):</span>\n        <span class=\"n\">index</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n    <span class=\"k\">return</span> <span class=\"n\">index</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">PrebuiltOffsetIndex</span><span class=\"p\">(</span><span class=\"n\">xml</span><span class=\"o\">.</span><span class=\"n\">FlatTagSpecificXMLByteIndex</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;An Offset Index class which just holds offsets</span>\n<span class=\"sd\">    and performs no extra scanning effort.</span>\n\n<span class=\"sd\">    Attributes</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    offsets : ByteEncodingOrderedDict</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">offsets</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">offsets</span> <span class=\"o\">=</span> <span class=\"n\">offsets</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">IndexSavingXML</span><span class=\"p\">(</span><span class=\"n\">xml</span><span class=\"o\">.</span><span class=\"n\">IndexedXML</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;An extension to the IndexedXML type which</span>\n<span class=\"sd\">    adds facilities to read and write the byte offset</span>\n<span class=\"sd\">    index externally.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"n\">_save_byte_index_to_file</span> <span class=\"o\">=</span> <span class=\"nb\">staticmethod</span><span class=\"p\">(</span><span class=\"n\">save_byte_index</span><span class=\"p\">)</span>\n    <span class=\"n\">_load_byte_index_from_file</span> <span class=\"o\">=</span> <span class=\"nb\">staticmethod</span><span class=\"p\">(</span><span class=\"n\">load_byte_index</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_byte_offset_filename</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_source</span><span class=\"o\">.</span><span class=\"n\">name</span>\n        <span class=\"n\">byte_offset_filename</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">splitext</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;-byte-offsets.json&#39;</span>\n        <span class=\"k\">return</span> <span class=\"n\">byte_offset_filename</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_check_has_byte_offset_file</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_byte_offset_filename</span>\n        <span class=\"k\">return</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">exists</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_read_byte_offsets</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_byte_offset_filename</span><span class=\"p\">,</span> <span class=\"s1\">&#39;r&#39;</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n            <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">PrebuiltOffsetIndex</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_load_byte_index_from_file</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_offset_index</span> <span class=\"o\">=</span> <span class=\"n\">index</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_write_byte_offsets</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_byte_offset_filename</span><span class=\"p\">,</span> <span class=\"s1\">&#39;w&#39;</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_save_byte_index_to_file</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_offset_index</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@xml._keepstate</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_build_index</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_read_byte_offsets</span><span class=\"p\">()</span>\n        <span class=\"k\">except</span> <span class=\"ne\">IOError</span><span class=\"p\">:</span>\n            <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">IndexSavingXML</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">_build_index</span><span class=\"p\">()</span>\n\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">prebuild_byte_offset_file</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">path</span><span class=\"p\">):</span>\n        <span class=\"n\">inst</span> <span class=\"o\">=</span> <span class=\"bp\">cls</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">use_index</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n        <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">_write_byte_offsets</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>If you agree this is a good idea, I'll integrate this into my fork and make <code>MzML</code> and <code>MzXML</code> descend from this class instead of IndexedXML directly.</p>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": null, "edited_on": null, "created_on": "2017-08-22T23:51:12.718655+00:00", "milestone": null, "updated_on": "2017-08-25T22:38:54.943099+00:00", "type": "issue", "id": 17}