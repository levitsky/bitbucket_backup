{"priority": "major", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "links": {"attachments": {"href": "data/repositories/levitsky/pyteomics/issues/15/attachments_page=1.json"}, "self": {"href": "data/repositories/levitsky/pyteomics/issues/15.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/levitsky/pyteomics/issues/15/watch"}, "comments": {"href": "data/repositories/levitsky/pyteomics/issues/15/comments_page=1.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/15/cvparam-unit-awareness"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/levitsky/pyteomics/issues/15/vote"}}, "reporter": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "title": "cvParam Unit Awareness", "component": null, "votes": 0, "watches": 1, "content": {"raw": "The current logic for handling cvParam tags in PSIMS standard XML documents discards unit information. \r\n\r\n```python\r\n    def _handle_param(self, element, **kwargs):\r\n        \"\"\"Unpacks cvParam and userParam tags into key-value pairs\"\"\"\r\n        types = {'int': int, 'float': float, 'string': str}\r\n        if 'value' in element.attrib:\r\n            try:\r\n                if element.attrib.get('type') in types:\r\n                    value = types[element.attrib['type']](element.attrib['value'])\r\n                else:\r\n                    value = float(element.attrib['value'])\r\n            except ValueError:\r\n                value = element.attrib['value']\r\n            return {element.attrib['name']: value}\r\n        else:\r\n            return {'name': element.attrib['name']}\r\n```\r\n\r\nHere, if a unit were present, there would be attributes such as unitCVRef, unitAccession, and unitName. The first two attributes together can be used to resolve the definition of the unit from a controlled vocabulary, while the third gives a common name for the unit, which is usually enough context for a program to make the correct decision. Since this value is discarded before it reaches the caller, that is impossible. For example, some time-related fields are recorded in minutes while others are in seconds.\r\n\r\nI propose three solutions for consideration:\r\n\r\n1. Create a new \"Parameter\" type which wraps all of the information contained in the cvParam tag, and force all callers to unwrap the object to access the primitive value therein. This breaks all client code but is more future-proof and provides more semantic information.\r\n2. Create a set of data type specific wrappers for `float`, `int`, and `str` that inherit from the matching builtin type, which has a spot for storing the unit (and other metadata?). This doesn't break client code, but it may mean that unit information is lost when passed through conversion operations.\r\n3. Rather than create our own wrappers, use a library like [units](https://pypi.python.org/pypi/units) or [pint](https://github.com/hgrecco/pint) to provide this behavior. These types have been through more testing, but also support dimensionality checking so that you can operate on quantities of the same dimension or dimensionless quantities, but institutes error checking when operating on non-conforming dimensions together. This is hard to predict how it will break client code.\r\n\r\nI'm partial to option 2 since 1 involves a lot of rewriting of code that doesn't really care about units, and option 3 is hard to analyze and adds a new dependency that can break in unpredictable ways.\r\n\r\nI'm planning to start work on this issue in a few days, but I wanted to get the options reviewed before I started.", "markup": "markdown", "html": "<p>The current logic for handling cvParam tags in PSIMS standard XML documents discards unit information. </p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"nf\">_handle_param</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Unpacks cvParam and userParam tags into key-value pairs&quot;&quot;&quot;</span>\n        <span class=\"n\">types</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;int&#39;</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"s1\">&#39;float&#39;</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"s1\">&#39;string&#39;</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">}</span>\n        <span class=\"k\">if</span> <span class=\"s1\">&#39;value&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;type&#39;</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">:</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">types</span><span class=\"p\">[</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;type&#39;</span><span class=\"p\">]](</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">])</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">])</span>\n            <span class=\"k\">except</span> <span class=\"ne\">ValueError</span><span class=\"p\">:</span>\n                <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">]</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;name&#39;</span><span class=\"p\">]:</span> <span class=\"n\">value</span><span class=\"p\">}</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s1\">&#39;name&#39;</span><span class=\"p\">:</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">[</span><span class=\"s1\">&#39;name&#39;</span><span class=\"p\">]}</span>\n</pre></div>\n\n\n<p>Here, if a unit were present, there would be attributes such as unitCVRef, unitAccession, and unitName. The first two attributes together can be used to resolve the definition of the unit from a controlled vocabulary, while the third gives a common name for the unit, which is usually enough context for a program to make the correct decision. Since this value is discarded before it reaches the caller, that is impossible. For example, some time-related fields are recorded in minutes while others are in seconds.</p>\n<p>I propose three solutions for consideration:</p>\n<ol>\n<li>Create a new \"Parameter\" type which wraps all of the information contained in the cvParam tag, and force all callers to unwrap the object to access the primitive value therein. This breaks all client code but is more future-proof and provides more semantic information.</li>\n<li>Create a set of data type specific wrappers for <code>float</code>, <code>int</code>, and <code>str</code> that inherit from the matching builtin type, which has a spot for storing the unit (and other metadata?). This doesn't break client code, but it may mean that unit information is lost when passed through conversion operations.</li>\n<li>Rather than create our own wrappers, use a library like <a data-is-external-link=\"true\" href=\"https://pypi.python.org/pypi/units\" rel=\"nofollow\">units</a> or <a data-is-external-link=\"true\" href=\"https://github.com/hgrecco/pint\" rel=\"nofollow\">pint</a> to provide this behavior. These types have been through more testing, but also support dimensionality checking so that you can operate on quantities of the same dimension or dimensionless quantities, but institutes error checking when operating on non-conforming dimensions together. This is hard to predict how it will break client code.</li>\n</ol>\n<p>I'm partial to option 2 since 1 involves a lot of rewriting of code that doesn't really care about units, and option 3 is hard to analyze and adds a new dependency that can break in unpredictable ways.</p>\n<p>I'm planning to start work on this issue in a few days, but I wanted to get the options reviewed before I started.</p>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": null, "edited_on": null, "created_on": "2017-01-03T23:47:45.453066+00:00", "milestone": null, "updated_on": "2017-01-12T13:08:56.100442+00:00", "type": "issue", "id": 15}