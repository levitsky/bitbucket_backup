{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/12/comments/22985948.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/12#comment-22985948"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/12.json"}}, "type": "issue", "id": 12, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "Unimod Alternative Names Missing"}, "content": {"raw": "Issue #1 seems to be the result of testing the raw query in an interactive session and then not copying it correctly to the text file. `|` has higher affinity than `or`. Rerunning the method call from the outside works now.\n\nIssue #2 can be solved three ways, depending upon how the composition is encoded in the database. For cases where a \"composition\" column is present, a simple parser can be used at the moment a model object (all types inheriting from Base are models) is constructed from a query result to translate the \"composition\" value from a formula into a Composition instance. For example, Acetyl is encoded with \"H(2) C(2) O\", which translates to `{\"H\": 2, \"C\": 2, \"O\": 1}`. This is also the case for `SpecificityToNeutralLoss`. However, `Brick`s are different, for whatever reason. Some bricks are just elements, in fact I think they're analogous to the elem component you parsed to build `self._massdata`. Other `Brick`s are molecules like acetate or monosaccharides. The definition of a Brick is not actually listed on Unimod's website, but it can be found in Proteowizard source code comments like [this](https://codecov.io/github/Bioconductor-mirror/mzR/src/pwiz/data/common/Unimod.cpp?ref=b6aa99c2b36dbf0b718c075093a1f8809cfae5b9#l-50) that they're used to compose formulae for modifications. Their elemental composition is encoded through a join-table, so instead of an event listener, a simple property decorator is easier than generating complicated SQL on load.\n\nI implemented the by_name and aliased it to by_title since there are now many more than two names, but there should be no ambiguity where the title of one modification is the name of another. To handle strictness, equality is handled as normal, and `contains` is emulated using an SQL `LIKE` operator with the query identifier padded with wildcards. `Unimod.mods` was simple, but, `mass_data` is harder because of the distinction between `Brick` and `Element`. The `Element` entries are unaware of specific isotopes, providing just monisotopic and average masses, while `Brick` versions of each element are particular to a specific isotope, but frequency information is missing. I can see you're doing something to back-solve the abundance of different isotopes using the average mass as a point of reference, but it's opaque. How important is that information?", "markup": "markdown", "html": "<p>Issue <a href=\"#!/levitsky/pyteomics/issues/1/missing-iter_spectrum-function\" rel=\"nofollow\" title=\"Missing iter_spectrum function...\" class=\"ap-connect-link\"><s>#1</s></a> seems to be the result of testing the raw query in an interactive session and then not copying it correctly to the text file. <code>|</code> has higher affinity than <code>or</code>. Rerunning the method call from the outside works now.</p>\n<p>Issue <a href=\"#!/levitsky/pyteomics/issues/2/compositions-from-modx-bug\" rel=\"nofollow\" title=\"Compositions from modX Bug\" class=\"ap-connect-link\"><s>#2</s></a> can be solved three ways, depending upon how the composition is encoded in the database. For cases where a \"composition\" column is present, a simple parser can be used at the moment a model object (all types inheriting from Base are models) is constructed from a query result to translate the \"composition\" value from a formula into a Composition instance. For example, Acetyl is encoded with \"H(2) C(2) O\", which translates to <code>{\"H\": 2, \"C\": 2, \"O\": 1}</code>. This is also the case for <code>SpecificityToNeutralLoss</code>. However, <code>Brick</code>s are different, for whatever reason. Some bricks are just elements, in fact I think they're analogous to the elem component you parsed to build <code>self._massdata</code>. Other <code>Brick</code>s are molecules like acetate or monosaccharides. The definition of a Brick is not actually listed on Unimod's website, but it can be found in Proteowizard source code comments like <a data-is-external-link=\"true\" href=\"https://codecov.io/github/Bioconductor-mirror/mzR/src/pwiz/data/common/Unimod.cpp?ref=b6aa99c2b36dbf0b718c075093a1f8809cfae5b9#l-50\" rel=\"nofollow\">this</a> that they're used to compose formulae for modifications. Their elemental composition is encoded through a join-table, so instead of an event listener, a simple property decorator is easier than generating complicated SQL on load.</p>\n<p>I implemented the by_name and aliased it to by_title since there are now many more than two names, but there should be no ambiguity where the title of one modification is the name of another. To handle strictness, equality is handled as normal, and <code>contains</code> is emulated using an SQL <code>LIKE</code> operator with the query identifier padded with wildcards. <code>Unimod.mods</code> was simple, but, <code>mass_data</code> is harder because of the distinction between <code>Brick</code> and <code>Element</code>. The <code>Element</code> entries are unaware of specific isotopes, providing just monisotopic and average masses, while <code>Brick</code> versions of each element are particular to a specific isotope, but frequency information is missing. I can see you're doing something to back-solve the abundance of different isotopes using the average mass as a point of reference, but it's opaque. How important is that information?</p>", "type": "rendered"}, "created_on": "2015-11-01T19:54:31.053225+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": null, "type": "issue_comment", "id": 22985948}