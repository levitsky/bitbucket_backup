{"priority": "minor", "kind": "proposal", "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "links": {"attachments": {"href": "data/repositories/levitsky/pyteomics/issues/12/attachments_page=1.json"}, "self": {"href": "data/repositories/levitsky/pyteomics/issues/12.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/levitsky/pyteomics/issues/12/watch"}, "comments": {"href": "data/repositories/levitsky/pyteomics/issues/12/comments_page=1.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/12/unimod-alternative-names-missing"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/levitsky/pyteomics/issues/12/vote"}}, "reporter": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "title": "Unimod Alternative Names Missing", "component": null, "votes": 0, "watches": 2, "content": {"raw": "I'm opening this issue to start a discussion about how to interface with Unimod.\r\n\r\nThere is a disconnect between the logical structure XML and the relational structure XML that Unimod publishes. The logical structure is missing the notion of \"alternative names\", which are present in the relational structure.\r\n\r\nI ran into an issue processing a large mzIdentML file using only the names provided in the logical structure, where for instance the name \"GlyGly\" was used, to refer to \"ubiquitination residue\", and croaked. After some digging I decided to extract the complete object hierarchy from the relational structure.\r\n\r\nOnce the data is loaded, the user creates an instance of the `Unimod` type which they can query using normal `__getitem__` syntax or by using the `get` method (which `__getitem__` is an alias of) with either a number which will be treated as the Unimod accession number, or a string which is will be matched against any name. The Unimod object wraps a SQLAlchemy session, which can be accessed directly under `.session` and queried using the ORM or Core SQL layer from there.\r\n\r\nSince I started with a relational point of view, I wrote my prototype with SQLAlchemy, which could either backend off disk or memory with SQLite3 in the standard library. If the interface I present is acceptable but the use of SQLAlchemy is a blocking issue, I can rewrite the hierarchy to manually track relationships.\r\n\r\nNaturally, a variation on the Unimod constructor would be desirable such that if passed no datastore path, it would fetch down the XML source and build a database in memory.", "markup": "markdown", "html": "<p>I'm opening this issue to start a discussion about how to interface with Unimod.</p>\n<p>There is a disconnect between the logical structure XML and the relational structure XML that Unimod publishes. The logical structure is missing the notion of \"alternative names\", which are present in the relational structure.</p>\n<p>I ran into an issue processing a large mzIdentML file using only the names provided in the logical structure, where for instance the name \"GlyGly\" was used, to refer to \"ubiquitination residue\", and croaked. After some digging I decided to extract the complete object hierarchy from the relational structure.</p>\n<p>Once the data is loaded, the user creates an instance of the <code>Unimod</code> type which they can query using normal <code>__getitem__</code> syntax or by using the <code>get</code> method (which <code>__getitem__</code> is an alias of) with either a number which will be treated as the Unimod accession number, or a string which is will be matched against any name. The Unimod object wraps a SQLAlchemy session, which can be accessed directly under <code>.session</code> and queried using the ORM or Core SQL layer from there.</p>\n<p>Since I started with a relational point of view, I wrote my prototype with SQLAlchemy, which could either backend off disk or memory with SQLite3 in the standard library. If the interface I present is acceptable but the use of SQLAlchemy is a blocking issue, I can rewrite the hierarchy to manually track relationships.</p>\n<p>Naturally, a variation on the Unimod constructor would be desirable such that if passed no datastore path, it would fetch down the XML source and build a database in memory.</p>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": null, "edited_on": null, "created_on": "2015-10-30T05:21:09.023429+00:00", "milestone": null, "updated_on": "2016-03-01T18:05:50.745869+00:00", "type": "issue", "id": 12}