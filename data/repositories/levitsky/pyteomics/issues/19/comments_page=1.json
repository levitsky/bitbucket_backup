{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19/comments/41275715.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/19#comment-41275715"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19.json"}}, "type": "issue", "id": 19, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "More of a question than issue"}, "content": {"raw": "Hi Mateusz,\n\nthank you for using Pyteomics and for your kind feedback.\n\nThe m/z and intensities from each scan are decoded from binary as numpy arrays, rather than one by one, so no direct iterator is available.\nYou can emulate it by using `zip()` on the two arrays, though it won't save any RAM.\n\nBest regards,\nLev", "markup": "markdown", "html": "<p>Hi Mateusz,</p>\n<p>thank you for using Pyteomics and for your kind feedback.</p>\n<p>The m/z and intensities from each scan are decoded from binary as numpy arrays, rather than one by one, so no direct iterator is available.\nYou can emulate it by using <code>zip()</code> on the two arrays, though it won't save any RAM.</p>\n<p>Best regards,\nLev</p>", "type": "rendered"}, "created_on": "2017-11-17T11:48:59.231971+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": null, "type": "issue_comment", "id": 41275715}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19/comments/41275894.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/19#comment-41275894"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19.json"}}, "type": "issue", "id": 19, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "More of a question than issue"}, "content": {"raw": "Thanks for the reply!\n\nDo you have any out-of-the-box solution to aggregate the spectra from different runs?", "markup": "markdown", "html": "<p>Thanks for the reply!</p>\n<p>Do you have any out-of-the-box solution to aggregate the spectra from different runs?</p>", "type": "rendered"}, "created_on": "2017-11-17T11:56:10.621997+00:00", "user": {"display_name": "Matteo Lacki", "uuid": "{0aa740a7-9fa8-4a45-ad13-18e05528160e}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D"}, "html": {"href": "https://bitbucket.org/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/696a8c1520b815233582aa1bf923a809d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsML-5.png"}}, "nickname": "Mateusz \u0141\u0105cki", "type": "user", "account_id": "557058:aa1b63e0-6c01-4920-aa1a-b9e9368b25b2"}, "updated_on": null, "type": "issue_comment", "id": 41275894}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19/comments/41276194.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/19#comment-41276194"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19.json"}}, "type": "issue", "id": 19, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "More of a question than issue"}, "content": {"raw": "Do you mean to seamlessly iterate over multiple files, or to perform some kind of spectrum averaging?\n\nFor the former, you can use `mzxml.chain` instead of `mzxml.read`.\nFor the latter, no ready solution is available, but with numpy arrays it should not be too hard to do.\nLet me know if you have further questions.", "markup": "markdown", "html": "<p>Do you mean to seamlessly iterate over multiple files, or to perform some kind of spectrum averaging?</p>\n<p>For the former, you can use <code>mzxml.chain</code> instead of <code>mzxml.read</code>.\nFor the latter, no ready solution is available, but with numpy arrays it should not be too hard to do.\nLet me know if you have further questions.</p>", "type": "rendered"}, "created_on": "2017-11-17T12:07:20.940059+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": null, "type": "issue_comment", "id": 41276194}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19/comments/41283133.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/19#comment-41283133"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19.json"}}, "type": "issue", "id": 19, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "More of a question than issue"}, "content": {"raw": "I meant more or less the latter, though I don't want to average the spectra but to put them atop of each other.\n\nI will give you an example of more or less what I want to achieve as an output.\n\nLet S1 = {(10.1, 20), (12.2, 200)} and S2 = {(12.25, 50 ), (13.25, 200)} be two very simple spectra. Tuples contain m/z ratio and intensity.\n\nI want to:\n1. get rid of too small peaks (with height smaller than, say 40.0)\n2. round the m/z of the remaining peaks to one significant digit \n3. sum their intensities\nso as to obtain:\nS3 = {(12.2, 200+50=250), (13.25, 200)}\n\nYour software lets me iterate through S1, S2, ...\n\nIn pure python (ok, using numpy), this can be done using:\n\n\n```\n#!python\n\ndef threshold_round_and_aggregate_peaks(peaks,\n                                        spectral_intensity_cut_off=0.0,\n                                        precision_digits=2):\n    \"\"\"\n    Apply thresholding on peaks,\n    round their m/z values,\n    and aggregate the result.\n\n    Parameters\n    =======\n    peaks : iterable\n        Iterates over tuples (m_over_z, intensity).\n    spectral_intensity_cut_off : float\n\n    precision_digits : float\n        The number of digits after which the floats get rounded.\n    Remarks\n    =======\n    This function is purely pythonic (if the peak iterable is).\n    It is 8 times slower than the numpy version.\n    \"\"\"\n    nice_spectrum = Counter()\n    for mz, intensity in peaks:\n        if intensity >= spectral_intensity_cut_off:\n            nice_spectrum[round(mz, precision_digits)] += intensity\n    return Spectrum(mass=np.array(list(nice_spectrum.keys())),\n                    intensity=np.array(list(nice_spectrum.values())))\n\n```\n\nThat's ok, but since you already use numpy, it can be done four to six times faster, by calling read_spectrum_from_mzxml,\n\n\n```\n#!python\n\nSpectrum = namedtuple('Spectrum', 'mz intensity')\n\ndef aggregate(keys, values=None):\n    \"\"\"Aggregate values with the same keys.\n\n    Parameters\n    ----------\n    keys : array\n        Keys, usually m/z values.\n    values : array\n        Values to aggregate, usually intensities.\n\n    Returns\n    -------\n    out : tuple\n        A tuple containing unique keys and aggregated values.\n    \"\"\"\n    uniqueKeys, indices = np.unique(keys, return_inverse=True)\n    return uniqueKeys, np.bincount(indices, weights=values)\n\n\ndef stack_spectra(spec1, spec2):\n    \"\"\"Merge two spectra into one, aggregating out the common m/z values.\n\n    Parameters\n    ----------\n    spec1 : tuple of two numpy arrays\n        A mass spectrum:\n        an array of m/z ratios and an array of corresponding intensities.\n    spec2 : tuple of two numpy arrays\n        A mass spectrum:\n        an array of m/z ratios and an array of corresponding intensities.\n    \"\"\"\n    masses_over_charge = np.concatenate((spec1[0], spec2[0]))\n    intensities = np.concatenate((spec1[1], spec2[1]))\n    return aggregate(masses_over_charge, intensities)\n\n\ndef get_distributions_from_mzxml(path,\n                                 spectral_intensity_cut_off=0.0,\n                                 precision_digits=2):\n    \"\"\"\n    Generate a sequence of rounded and trimmed spectra from\n    individual runs of the instrument.\n\n    Parameters\n    ----------\n    path : str\n        Path to the mzXml file containing the mass spectrum.\n    spectral_intensity_cut_off : float\n        The cut off value for peak intensity.\n    precision_digits : float\n        The number of digits after which the floats get rounded.\n    Returns\n    -------\n    out : generator\n        Generates tuples of numpy arrays corresponding to different runs\n        of the experimental spectrum.\n    \"\"\"\n    with mzxml.read(path) as reader:\n        for spectrum in reader:\n            mzs = spectrum['m/z array']\n\n            intensities = spectrum['intensity array']\n\n            mzs = mzs[intensities >=\n                      spectral_intensity_cut_off]\n\n            mzs = np.round(mzs, precision_digits)\n            intensities = intensities[intensities >=\n                                      spectral_intensity_cut_off]\n            yield mzs, intensities\n\n\ndef read_spectrum_from_mzxml(path,\n                             spectral_intensity_cut_off=0.0,\n                             precision_digits=2):\n    \"\"\"\n    Read spectrum form an mzXml and merge runs of the instrument.\n    Parameters\n    ----------\n    path : str\n        Path to the mzXml file containing the mass spectrum.\n    spectral_intensity_cut_off : float\n        The cut off value for peak intensity.\n    precision_digits : float\n        The number of digits after which the floats get rounded.\n    Returns\n    -------\n    out : Spectrum\n    \"\"\"\n    mz, intensity = reduce(\n        stack_spectra,\n        get_distributions_from_mzxml(path,\n                                     spectral_intensity_cut_off,\n                                     precision_digits))\n    return Spectrum(mz=mz, intensity=intensity)\n\n\n```\n\nI was wondering if this can be done even faster.\nDo you read spectra in Python, or do you have some C library underneath?\n\nIf it's the latter, then it might be worthwile to write a generator in C and expose it to Python using CFFI.\n\nSorry for the code that is not reduced for the post, but I guess you can understand what I want to do anyway :)\n\nBest wishes!", "markup": "markdown", "html": "<p>I meant more or less the latter, though I don't want to average the spectra but to put them atop of each other.</p>\n<p>I will give you an example of more or less what I want to achieve as an output.</p>\n<p>Let S1 = {(10.1, 20), (12.2, 200)} and S2 = {(12.25, 50 ), (13.25, 200)} be two very simple spectra. Tuples contain m/z ratio and intensity.</p>\n<p>I want to:\n1. get rid of too small peaks (with height smaller than, say 40.0)\n2. round the m/z of the remaining peaks to one significant digit \n3. sum their intensities\nso as to obtain:\nS3 = {(12.2, 200+50=250), (13.25, 200)}</p>\n<p>Your software lets me iterate through S1, S2, ...</p>\n<p>In pure python (ok, using numpy), this can be done using:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">threshold_round_and_aggregate_peaks</span><span class=\"p\">(</span><span class=\"n\">peaks</span><span class=\"p\">,</span>\n                                        <span class=\"n\">spectral_intensity_cut_off</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span>\n                                        <span class=\"n\">precision_digits</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Apply thresholding on peaks,</span>\n<span class=\"sd\">    round their m/z values,</span>\n<span class=\"sd\">    and aggregate the result.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    =======</span>\n<span class=\"sd\">    peaks : iterable</span>\n<span class=\"sd\">        Iterates over tuples (m_over_z, intensity).</span>\n<span class=\"sd\">    spectral_intensity_cut_off : float</span>\n\n<span class=\"sd\">    precision_digits : float</span>\n<span class=\"sd\">        The number of digits after which the floats get rounded.</span>\n<span class=\"sd\">    Remarks</span>\n<span class=\"sd\">    =======</span>\n<span class=\"sd\">    This function is purely pythonic (if the peak iterable is).</span>\n<span class=\"sd\">    It is 8 times slower than the numpy version.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">nice_spectrum</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">mz</span><span class=\"p\">,</span> <span class=\"n\">intensity</span> <span class=\"ow\">in</span> <span class=\"n\">peaks</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">intensity</span> <span class=\"o\">&gt;=</span> <span class=\"n\">spectral_intensity_cut_off</span><span class=\"p\">:</span>\n            <span class=\"n\">nice_spectrum</span><span class=\"p\">[</span><span class=\"nb\">round</span><span class=\"p\">(</span><span class=\"n\">mz</span><span class=\"p\">,</span> <span class=\"n\">precision_digits</span><span class=\"p\">)]</span> <span class=\"o\">+=</span> <span class=\"n\">intensity</span>\n    <span class=\"k\">return</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"n\">mass</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nice_spectrum</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())),</span>\n                    <span class=\"n\">intensity</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nice_spectrum</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())))</span>\n</pre></div>\n\n\n<p>That's ok, but since you already use numpy, it can be done four to six times faster, by calling read_spectrum_from_mzxml,</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">Spectrum</span> <span class=\"o\">=</span> <span class=\"n\">namedtuple</span><span class=\"p\">(</span><span class=\"s1\">&#39;Spectrum&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;mz intensity&#39;</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">aggregate</span><span class=\"p\">(</span><span class=\"n\">keys</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Aggregate values with the same keys.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    keys : array</span>\n<span class=\"sd\">        Keys, usually m/z values.</span>\n<span class=\"sd\">    values : array</span>\n<span class=\"sd\">        Values to aggregate, usually intensities.</span>\n\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    out : tuple</span>\n<span class=\"sd\">        A tuple containing unique keys and aggregated values.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">uniqueKeys</span><span class=\"p\">,</span> <span class=\"n\">indices</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">keys</span><span class=\"p\">,</span> <span class=\"n\">return_inverse</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">uniqueKeys</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">bincount</span><span class=\"p\">(</span><span class=\"n\">indices</span><span class=\"p\">,</span> <span class=\"n\">weights</span><span class=\"o\">=</span><span class=\"n\">values</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">stack_spectra</span><span class=\"p\">(</span><span class=\"n\">spec1</span><span class=\"p\">,</span> <span class=\"n\">spec2</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Merge two spectra into one, aggregating out the common m/z values.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    spec1 : tuple of two numpy arrays</span>\n<span class=\"sd\">        A mass spectrum:</span>\n<span class=\"sd\">        an array of m/z ratios and an array of corresponding intensities.</span>\n<span class=\"sd\">    spec2 : tuple of two numpy arrays</span>\n<span class=\"sd\">        A mass spectrum:</span>\n<span class=\"sd\">        an array of m/z ratios and an array of corresponding intensities.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">masses_over_charge</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">spec1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">spec2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]))</span>\n    <span class=\"n\">intensities</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">spec1</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">spec2</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]))</span>\n    <span class=\"k\">return</span> <span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">masses_over_charge</span><span class=\"p\">,</span> <span class=\"n\">intensities</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">get_distributions_from_mzxml</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span>\n                                 <span class=\"n\">spectral_intensity_cut_off</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span>\n                                 <span class=\"n\">precision_digits</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Generate a sequence of rounded and trimmed spectra from</span>\n<span class=\"sd\">    individual runs of the instrument.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    path : str</span>\n<span class=\"sd\">        Path to the mzXml file containing the mass spectrum.</span>\n<span class=\"sd\">    spectral_intensity_cut_off : float</span>\n<span class=\"sd\">        The cut off value for peak intensity.</span>\n<span class=\"sd\">    precision_digits : float</span>\n<span class=\"sd\">        The number of digits after which the floats get rounded.</span>\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    out : generator</span>\n<span class=\"sd\">        Generates tuples of numpy arrays corresponding to different runs</span>\n<span class=\"sd\">        of the experimental spectrum.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">with</span> <span class=\"n\">mzxml</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">reader</span><span class=\"p\">:</span>\n        <span class=\"k\">for</span> <span class=\"n\">spectrum</span> <span class=\"ow\">in</span> <span class=\"n\">reader</span><span class=\"p\">:</span>\n            <span class=\"n\">mzs</span> <span class=\"o\">=</span> <span class=\"n\">spectrum</span><span class=\"p\">[</span><span class=\"s1\">&#39;m/z array&#39;</span><span class=\"p\">]</span>\n\n            <span class=\"n\">intensities</span> <span class=\"o\">=</span> <span class=\"n\">spectrum</span><span class=\"p\">[</span><span class=\"s1\">&#39;intensity array&#39;</span><span class=\"p\">]</span>\n\n            <span class=\"n\">mzs</span> <span class=\"o\">=</span> <span class=\"n\">mzs</span><span class=\"p\">[</span><span class=\"n\">intensities</span> <span class=\"o\">&gt;=</span>\n                      <span class=\"n\">spectral_intensity_cut_off</span><span class=\"p\">]</span>\n\n            <span class=\"n\">mzs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"n\">mzs</span><span class=\"p\">,</span> <span class=\"n\">precision_digits</span><span class=\"p\">)</span>\n            <span class=\"n\">intensities</span> <span class=\"o\">=</span> <span class=\"n\">intensities</span><span class=\"p\">[</span><span class=\"n\">intensities</span> <span class=\"o\">&gt;=</span>\n                                      <span class=\"n\">spectral_intensity_cut_off</span><span class=\"p\">]</span>\n            <span class=\"k\">yield</span> <span class=\"n\">mzs</span><span class=\"p\">,</span> <span class=\"n\">intensities</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">read_spectrum_from_mzxml</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span>\n                             <span class=\"n\">spectral_intensity_cut_off</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span>\n                             <span class=\"n\">precision_digits</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Read spectrum form an mzXml and merge runs of the instrument.</span>\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    path : str</span>\n<span class=\"sd\">        Path to the mzXml file containing the mass spectrum.</span>\n<span class=\"sd\">    spectral_intensity_cut_off : float</span>\n<span class=\"sd\">        The cut off value for peak intensity.</span>\n<span class=\"sd\">    precision_digits : float</span>\n<span class=\"sd\">        The number of digits after which the floats get rounded.</span>\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    out : Spectrum</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">mz</span><span class=\"p\">,</span> <span class=\"n\">intensity</span> <span class=\"o\">=</span> <span class=\"nb\">reduce</span><span class=\"p\">(</span>\n        <span class=\"n\">stack_spectra</span><span class=\"p\">,</span>\n        <span class=\"n\">get_distributions_from_mzxml</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span>\n                                     <span class=\"n\">spectral_intensity_cut_off</span><span class=\"p\">,</span>\n                                     <span class=\"n\">precision_digits</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"n\">mz</span><span class=\"o\">=</span><span class=\"n\">mz</span><span class=\"p\">,</span> <span class=\"n\">intensity</span><span class=\"o\">=</span><span class=\"n\">intensity</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>I was wondering if this can be done even faster.\nDo you read spectra in Python, or do you have some C library underneath?</p>\n<p>If it's the latter, then it might be worthwile to write a generator in C and expose it to Python using CFFI.</p>\n<p>Sorry for the code that is not reduced for the post, but I guess you can understand what I want to do anyway :)</p>\n<p>Best wishes!</p>", "type": "rendered"}, "created_on": "2017-11-17T16:28:18.188061+00:00", "user": {"display_name": "Matteo Lacki", "uuid": "{0aa740a7-9fa8-4a45-ad13-18e05528160e}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D"}, "html": {"href": "https://bitbucket.org/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/696a8c1520b815233582aa1bf923a809d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsML-5.png"}}, "nickname": "Mateusz \u0141\u0105cki", "type": "user", "account_id": "557058:aa1b63e0-6c01-4920-aa1a-b9e9368b25b2"}, "updated_on": null, "type": "issue_comment", "id": 41283133}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19/comments/41295157.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/19#comment-41295157"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19.json"}}, "type": "issue", "id": 19, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "More of a question than issue"}, "content": {"raw": "All low-level XML parsing is done using `lxml`, a Python binding for `libxml2`. Using the iterative parsing interface that library provides in Python, we recursively unpack XML subtrees into nested `dict` objects. One of those tags is the `<peaks>` tag which holds the m/z, intensity pairs for containing `<scan>` tag.\n\nIf you're not interested in any metadata, and you're able to assume that every scan should be aggregated (e.g. no interleaved MS1 and MS2 scans), then you can use this technique to get access to a structured numpy array of (m/z, intensity) pairs:\n\n```python\nfrom pyteomics import mzxml\nfrom lxml import etree\n\ndef iterpeaks(path):\n    for event, tag in etree.iterparse(path):\n        if tag.tag.endswith(\"peaks\"):\n            yield mzxml._decode_peaks(tag.attrib, tag.text)\n        tag.clear()\n```\n\nThe structured array positions are pairs, but you can access the \"m/z array\" and \"intensity array\" dimensions by passing those string keys instead of numerical indices. \n\nThis read all the peaks out of an mzXML file with 14600 scans in 6.4 seconds compared to 10.6 seconds. Most of this time is spent on decompression and base64 decoding, both of which are calling into modules implemented in C in the standard library.", "markup": "markdown", "html": "<p>All low-level XML parsing is done using <code>lxml</code>, a Python binding for <code>libxml2</code>. Using the iterative parsing interface that library provides in Python, we recursively unpack XML subtrees into nested <code>dict</code> objects. One of those tags is the <code>&lt;peaks&gt;</code> tag which holds the m/z, intensity pairs for containing <code>&lt;scan&gt;</code> tag.</p>\n<p>If you're not interested in any metadata, and you're able to assume that every scan should be aggregated (e.g. no interleaved MS1 and MS2 scans), then you can use this technique to get access to a structured numpy array of (m/z, intensity) pairs:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">pyteomics</span> <span class=\"kn\">import</span> <span class=\"n\">mzxml</span>\n<span class=\"kn\">from</span> <span class=\"nn\">lxml</span> <span class=\"kn\">import</span> <span class=\"n\">etree</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">iterpeaks</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">tag</span> <span class=\"ow\">in</span> <span class=\"n\">etree</span><span class=\"o\">.</span><span class=\"n\">iterparse</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">endswith</span><span class=\"p\">(</span><span class=\"s2\">&quot;peaks&quot;</span><span class=\"p\">):</span>\n            <span class=\"k\">yield</span> <span class=\"n\">mzxml</span><span class=\"o\">.</span><span class=\"n\">_decode_peaks</span><span class=\"p\">(</span><span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">,</span> <span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n        <span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">clear</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>The structured array positions are pairs, but you can access the \"m/z array\" and \"intensity array\" dimensions by passing those string keys instead of numerical indices. </p>\n<p>This read all the peaks out of an mzXML file with 14600 scans in 6.4 seconds compared to 10.6 seconds. Most of this time is spent on decompression and base64 decoding, both of which are calling into modules implemented in C in the standard library.</p>", "type": "rendered"}, "created_on": "2017-11-18T16:32:23.156372+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": null, "type": "issue_comment", "id": 41295157}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19/comments/41304174.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/19#comment-41304174"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19.json"}}, "type": "issue", "id": 19, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "More of a question than issue"}, "content": {"raw": "Cool, this really works faster. I didn't notice before that you can get tuples into a numpy array.\n\nThanks!", "markup": "markdown", "html": "<p>Cool, this really works faster. I didn't notice before that you can get tuples into a numpy array.</p>\n<p>Thanks!</p>", "type": "rendered"}, "created_on": "2017-11-19T18:57:55.726405+00:00", "user": {"display_name": "Matteo Lacki", "uuid": "{0aa740a7-9fa8-4a45-ad13-18e05528160e}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D"}, "html": {"href": "https://bitbucket.org/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/696a8c1520b815233582aa1bf923a809d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsML-5.png"}}, "nickname": "Mateusz \u0141\u0105cki", "type": "user", "account_id": "557058:aa1b63e0-6c01-4920-aa1a-b9e9368b25b2"}, "updated_on": null, "type": "issue_comment", "id": 41304174}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19/comments/41304180.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/19#comment-41304180"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19.json"}}, "type": "issue", "id": 19, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "More of a question than issue"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2017-11-19T18:58:06.282456+00:00", "user": {"display_name": "Matteo Lacki", "uuid": "{0aa740a7-9fa8-4a45-ad13-18e05528160e}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D"}, "html": {"href": "https://bitbucket.org/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/696a8c1520b815233582aa1bf923a809d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsML-5.png"}}, "nickname": "Mateusz \u0141\u0105cki", "type": "user", "account_id": "557058:aa1b63e0-6c01-4920-aa1a-b9e9368b25b2"}, "updated_on": null, "type": "issue_comment", "id": 41304180}], "page": 1, "size": 7}