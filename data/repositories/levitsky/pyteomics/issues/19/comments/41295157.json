{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19/comments/41295157.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/19#comment-41295157"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19.json"}}, "type": "issue", "id": 19, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "More of a question than issue"}, "content": {"raw": "All low-level XML parsing is done using `lxml`, a Python binding for `libxml2`. Using the iterative parsing interface that library provides in Python, we recursively unpack XML subtrees into nested `dict` objects. One of those tags is the `<peaks>` tag which holds the m/z, intensity pairs for containing `<scan>` tag.\n\nIf you're not interested in any metadata, and you're able to assume that every scan should be aggregated (e.g. no interleaved MS1 and MS2 scans), then you can use this technique to get access to a structured numpy array of (m/z, intensity) pairs:\n\n```python\nfrom pyteomics import mzxml\nfrom lxml import etree\n\ndef iterpeaks(path):\n    for event, tag in etree.iterparse(path):\n        if tag.tag.endswith(\"peaks\"):\n            yield mzxml._decode_peaks(tag.attrib, tag.text)\n        tag.clear()\n```\n\nThe structured array positions are pairs, but you can access the \"m/z array\" and \"intensity array\" dimensions by passing those string keys instead of numerical indices. \n\nThis read all the peaks out of an mzXML file with 14600 scans in 6.4 seconds compared to 10.6 seconds. Most of this time is spent on decompression and base64 decoding, both of which are calling into modules implemented in C in the standard library.", "markup": "markdown", "html": "<p>All low-level XML parsing is done using <code>lxml</code>, a Python binding for <code>libxml2</code>. Using the iterative parsing interface that library provides in Python, we recursively unpack XML subtrees into nested <code>dict</code> objects. One of those tags is the <code>&lt;peaks&gt;</code> tag which holds the m/z, intensity pairs for containing <code>&lt;scan&gt;</code> tag.</p>\n<p>If you're not interested in any metadata, and you're able to assume that every scan should be aggregated (e.g. no interleaved MS1 and MS2 scans), then you can use this technique to get access to a structured numpy array of (m/z, intensity) pairs:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">pyteomics</span> <span class=\"kn\">import</span> <span class=\"n\">mzxml</span>\n<span class=\"kn\">from</span> <span class=\"nn\">lxml</span> <span class=\"kn\">import</span> <span class=\"n\">etree</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">iterpeaks</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">tag</span> <span class=\"ow\">in</span> <span class=\"n\">etree</span><span class=\"o\">.</span><span class=\"n\">iterparse</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">endswith</span><span class=\"p\">(</span><span class=\"s2\">&quot;peaks&quot;</span><span class=\"p\">):</span>\n            <span class=\"k\">yield</span> <span class=\"n\">mzxml</span><span class=\"o\">.</span><span class=\"n\">_decode_peaks</span><span class=\"p\">(</span><span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">attrib</span><span class=\"p\">,</span> <span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n        <span class=\"n\">tag</span><span class=\"o\">.</span><span class=\"n\">clear</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>The structured array positions are pairs, but you can access the \"m/z array\" and \"intensity array\" dimensions by passing those string keys instead of numerical indices. </p>\n<p>This read all the peaks out of an mzXML file with 14600 scans in 6.4 seconds compared to 10.6 seconds. Most of this time is spent on decompression and base64 decoding, both of which are calling into modules implemented in C in the standard library.</p>", "type": "rendered"}, "created_on": "2017-11-18T16:32:23.156372+00:00", "user": {"display_name": "Joshua Klein", "uuid": "{919f0add-304d-4b9a-8889-d2622a3dbc96}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D"}, "html": {"href": "https://bitbucket.org/%7B919f0add-304d-4b9a-8889-d2622a3dbc96%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/7d0e70bc74f783efa621a2bdd228ca22d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJK-3.png"}}, "nickname": "mobiusklein", "type": "user", "account_id": "557058:ff82222f-afe5-4135-a1b7-8de99a00f669"}, "updated_on": null, "type": "issue_comment", "id": 41295157}