{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19/comments/41283133.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/19#comment-41283133"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/19.json"}}, "type": "issue", "id": 19, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "More of a question than issue"}, "content": {"raw": "I meant more or less the latter, though I don't want to average the spectra but to put them atop of each other.\n\nI will give you an example of more or less what I want to achieve as an output.\n\nLet S1 = {(10.1, 20), (12.2, 200)} and S2 = {(12.25, 50 ), (13.25, 200)} be two very simple spectra. Tuples contain m/z ratio and intensity.\n\nI want to:\n1. get rid of too small peaks (with height smaller than, say 40.0)\n2. round the m/z of the remaining peaks to one significant digit \n3. sum their intensities\nso as to obtain:\nS3 = {(12.2, 200+50=250), (13.25, 200)}\n\nYour software lets me iterate through S1, S2, ...\n\nIn pure python (ok, using numpy), this can be done using:\n\n\n```\n#!python\n\ndef threshold_round_and_aggregate_peaks(peaks,\n                                        spectral_intensity_cut_off=0.0,\n                                        precision_digits=2):\n    \"\"\"\n    Apply thresholding on peaks,\n    round their m/z values,\n    and aggregate the result.\n\n    Parameters\n    =======\n    peaks : iterable\n        Iterates over tuples (m_over_z, intensity).\n    spectral_intensity_cut_off : float\n\n    precision_digits : float\n        The number of digits after which the floats get rounded.\n    Remarks\n    =======\n    This function is purely pythonic (if the peak iterable is).\n    It is 8 times slower than the numpy version.\n    \"\"\"\n    nice_spectrum = Counter()\n    for mz, intensity in peaks:\n        if intensity >= spectral_intensity_cut_off:\n            nice_spectrum[round(mz, precision_digits)] += intensity\n    return Spectrum(mass=np.array(list(nice_spectrum.keys())),\n                    intensity=np.array(list(nice_spectrum.values())))\n\n```\n\nThat's ok, but since you already use numpy, it can be done four to six times faster, by calling read_spectrum_from_mzxml,\n\n\n```\n#!python\n\nSpectrum = namedtuple('Spectrum', 'mz intensity')\n\ndef aggregate(keys, values=None):\n    \"\"\"Aggregate values with the same keys.\n\n    Parameters\n    ----------\n    keys : array\n        Keys, usually m/z values.\n    values : array\n        Values to aggregate, usually intensities.\n\n    Returns\n    -------\n    out : tuple\n        A tuple containing unique keys and aggregated values.\n    \"\"\"\n    uniqueKeys, indices = np.unique(keys, return_inverse=True)\n    return uniqueKeys, np.bincount(indices, weights=values)\n\n\ndef stack_spectra(spec1, spec2):\n    \"\"\"Merge two spectra into one, aggregating out the common m/z values.\n\n    Parameters\n    ----------\n    spec1 : tuple of two numpy arrays\n        A mass spectrum:\n        an array of m/z ratios and an array of corresponding intensities.\n    spec2 : tuple of two numpy arrays\n        A mass spectrum:\n        an array of m/z ratios and an array of corresponding intensities.\n    \"\"\"\n    masses_over_charge = np.concatenate((spec1[0], spec2[0]))\n    intensities = np.concatenate((spec1[1], spec2[1]))\n    return aggregate(masses_over_charge, intensities)\n\n\ndef get_distributions_from_mzxml(path,\n                                 spectral_intensity_cut_off=0.0,\n                                 precision_digits=2):\n    \"\"\"\n    Generate a sequence of rounded and trimmed spectra from\n    individual runs of the instrument.\n\n    Parameters\n    ----------\n    path : str\n        Path to the mzXml file containing the mass spectrum.\n    spectral_intensity_cut_off : float\n        The cut off value for peak intensity.\n    precision_digits : float\n        The number of digits after which the floats get rounded.\n    Returns\n    -------\n    out : generator\n        Generates tuples of numpy arrays corresponding to different runs\n        of the experimental spectrum.\n    \"\"\"\n    with mzxml.read(path) as reader:\n        for spectrum in reader:\n            mzs = spectrum['m/z array']\n\n            intensities = spectrum['intensity array']\n\n            mzs = mzs[intensities >=\n                      spectral_intensity_cut_off]\n\n            mzs = np.round(mzs, precision_digits)\n            intensities = intensities[intensities >=\n                                      spectral_intensity_cut_off]\n            yield mzs, intensities\n\n\ndef read_spectrum_from_mzxml(path,\n                             spectral_intensity_cut_off=0.0,\n                             precision_digits=2):\n    \"\"\"\n    Read spectrum form an mzXml and merge runs of the instrument.\n    Parameters\n    ----------\n    path : str\n        Path to the mzXml file containing the mass spectrum.\n    spectral_intensity_cut_off : float\n        The cut off value for peak intensity.\n    precision_digits : float\n        The number of digits after which the floats get rounded.\n    Returns\n    -------\n    out : Spectrum\n    \"\"\"\n    mz, intensity = reduce(\n        stack_spectra,\n        get_distributions_from_mzxml(path,\n                                     spectral_intensity_cut_off,\n                                     precision_digits))\n    return Spectrum(mz=mz, intensity=intensity)\n\n\n```\n\nI was wondering if this can be done even faster.\nDo you read spectra in Python, or do you have some C library underneath?\n\nIf it's the latter, then it might be worthwile to write a generator in C and expose it to Python using CFFI.\n\nSorry for the code that is not reduced for the post, but I guess you can understand what I want to do anyway :)\n\nBest wishes!", "markup": "markdown", "html": "<p>I meant more or less the latter, though I don't want to average the spectra but to put them atop of each other.</p>\n<p>I will give you an example of more or less what I want to achieve as an output.</p>\n<p>Let S1 = {(10.1, 20), (12.2, 200)} and S2 = {(12.25, 50 ), (13.25, 200)} be two very simple spectra. Tuples contain m/z ratio and intensity.</p>\n<p>I want to:\n1. get rid of too small peaks (with height smaller than, say 40.0)\n2. round the m/z of the remaining peaks to one significant digit \n3. sum their intensities\nso as to obtain:\nS3 = {(12.2, 200+50=250), (13.25, 200)}</p>\n<p>Your software lets me iterate through S1, S2, ...</p>\n<p>In pure python (ok, using numpy), this can be done using:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">threshold_round_and_aggregate_peaks</span><span class=\"p\">(</span><span class=\"n\">peaks</span><span class=\"p\">,</span>\n                                        <span class=\"n\">spectral_intensity_cut_off</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span>\n                                        <span class=\"n\">precision_digits</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Apply thresholding on peaks,</span>\n<span class=\"sd\">    round their m/z values,</span>\n<span class=\"sd\">    and aggregate the result.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    =======</span>\n<span class=\"sd\">    peaks : iterable</span>\n<span class=\"sd\">        Iterates over tuples (m_over_z, intensity).</span>\n<span class=\"sd\">    spectral_intensity_cut_off : float</span>\n\n<span class=\"sd\">    precision_digits : float</span>\n<span class=\"sd\">        The number of digits after which the floats get rounded.</span>\n<span class=\"sd\">    Remarks</span>\n<span class=\"sd\">    =======</span>\n<span class=\"sd\">    This function is purely pythonic (if the peak iterable is).</span>\n<span class=\"sd\">    It is 8 times slower than the numpy version.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">nice_spectrum</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">mz</span><span class=\"p\">,</span> <span class=\"n\">intensity</span> <span class=\"ow\">in</span> <span class=\"n\">peaks</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">intensity</span> <span class=\"o\">&gt;=</span> <span class=\"n\">spectral_intensity_cut_off</span><span class=\"p\">:</span>\n            <span class=\"n\">nice_spectrum</span><span class=\"p\">[</span><span class=\"nb\">round</span><span class=\"p\">(</span><span class=\"n\">mz</span><span class=\"p\">,</span> <span class=\"n\">precision_digits</span><span class=\"p\">)]</span> <span class=\"o\">+=</span> <span class=\"n\">intensity</span>\n    <span class=\"k\">return</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"n\">mass</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nice_spectrum</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())),</span>\n                    <span class=\"n\">intensity</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nice_spectrum</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())))</span>\n</pre></div>\n\n\n<p>That's ok, but since you already use numpy, it can be done four to six times faster, by calling read_spectrum_from_mzxml,</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">Spectrum</span> <span class=\"o\">=</span> <span class=\"n\">namedtuple</span><span class=\"p\">(</span><span class=\"s1\">&#39;Spectrum&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;mz intensity&#39;</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">aggregate</span><span class=\"p\">(</span><span class=\"n\">keys</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Aggregate values with the same keys.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    keys : array</span>\n<span class=\"sd\">        Keys, usually m/z values.</span>\n<span class=\"sd\">    values : array</span>\n<span class=\"sd\">        Values to aggregate, usually intensities.</span>\n\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    out : tuple</span>\n<span class=\"sd\">        A tuple containing unique keys and aggregated values.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">uniqueKeys</span><span class=\"p\">,</span> <span class=\"n\">indices</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">keys</span><span class=\"p\">,</span> <span class=\"n\">return_inverse</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">uniqueKeys</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">bincount</span><span class=\"p\">(</span><span class=\"n\">indices</span><span class=\"p\">,</span> <span class=\"n\">weights</span><span class=\"o\">=</span><span class=\"n\">values</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">stack_spectra</span><span class=\"p\">(</span><span class=\"n\">spec1</span><span class=\"p\">,</span> <span class=\"n\">spec2</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Merge two spectra into one, aggregating out the common m/z values.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    spec1 : tuple of two numpy arrays</span>\n<span class=\"sd\">        A mass spectrum:</span>\n<span class=\"sd\">        an array of m/z ratios and an array of corresponding intensities.</span>\n<span class=\"sd\">    spec2 : tuple of two numpy arrays</span>\n<span class=\"sd\">        A mass spectrum:</span>\n<span class=\"sd\">        an array of m/z ratios and an array of corresponding intensities.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">masses_over_charge</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">spec1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">spec2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]))</span>\n    <span class=\"n\">intensities</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">spec1</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">spec2</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]))</span>\n    <span class=\"k\">return</span> <span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">masses_over_charge</span><span class=\"p\">,</span> <span class=\"n\">intensities</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">get_distributions_from_mzxml</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span>\n                                 <span class=\"n\">spectral_intensity_cut_off</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span>\n                                 <span class=\"n\">precision_digits</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Generate a sequence of rounded and trimmed spectra from</span>\n<span class=\"sd\">    individual runs of the instrument.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    path : str</span>\n<span class=\"sd\">        Path to the mzXml file containing the mass spectrum.</span>\n<span class=\"sd\">    spectral_intensity_cut_off : float</span>\n<span class=\"sd\">        The cut off value for peak intensity.</span>\n<span class=\"sd\">    precision_digits : float</span>\n<span class=\"sd\">        The number of digits after which the floats get rounded.</span>\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    out : generator</span>\n<span class=\"sd\">        Generates tuples of numpy arrays corresponding to different runs</span>\n<span class=\"sd\">        of the experimental spectrum.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">with</span> <span class=\"n\">mzxml</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">reader</span><span class=\"p\">:</span>\n        <span class=\"k\">for</span> <span class=\"n\">spectrum</span> <span class=\"ow\">in</span> <span class=\"n\">reader</span><span class=\"p\">:</span>\n            <span class=\"n\">mzs</span> <span class=\"o\">=</span> <span class=\"n\">spectrum</span><span class=\"p\">[</span><span class=\"s1\">&#39;m/z array&#39;</span><span class=\"p\">]</span>\n\n            <span class=\"n\">intensities</span> <span class=\"o\">=</span> <span class=\"n\">spectrum</span><span class=\"p\">[</span><span class=\"s1\">&#39;intensity array&#39;</span><span class=\"p\">]</span>\n\n            <span class=\"n\">mzs</span> <span class=\"o\">=</span> <span class=\"n\">mzs</span><span class=\"p\">[</span><span class=\"n\">intensities</span> <span class=\"o\">&gt;=</span>\n                      <span class=\"n\">spectral_intensity_cut_off</span><span class=\"p\">]</span>\n\n            <span class=\"n\">mzs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"n\">mzs</span><span class=\"p\">,</span> <span class=\"n\">precision_digits</span><span class=\"p\">)</span>\n            <span class=\"n\">intensities</span> <span class=\"o\">=</span> <span class=\"n\">intensities</span><span class=\"p\">[</span><span class=\"n\">intensities</span> <span class=\"o\">&gt;=</span>\n                                      <span class=\"n\">spectral_intensity_cut_off</span><span class=\"p\">]</span>\n            <span class=\"k\">yield</span> <span class=\"n\">mzs</span><span class=\"p\">,</span> <span class=\"n\">intensities</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">read_spectrum_from_mzxml</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span>\n                             <span class=\"n\">spectral_intensity_cut_off</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span>\n                             <span class=\"n\">precision_digits</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Read spectrum form an mzXml and merge runs of the instrument.</span>\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    path : str</span>\n<span class=\"sd\">        Path to the mzXml file containing the mass spectrum.</span>\n<span class=\"sd\">    spectral_intensity_cut_off : float</span>\n<span class=\"sd\">        The cut off value for peak intensity.</span>\n<span class=\"sd\">    precision_digits : float</span>\n<span class=\"sd\">        The number of digits after which the floats get rounded.</span>\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    out : Spectrum</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">mz</span><span class=\"p\">,</span> <span class=\"n\">intensity</span> <span class=\"o\">=</span> <span class=\"nb\">reduce</span><span class=\"p\">(</span>\n        <span class=\"n\">stack_spectra</span><span class=\"p\">,</span>\n        <span class=\"n\">get_distributions_from_mzxml</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span>\n                                     <span class=\"n\">spectral_intensity_cut_off</span><span class=\"p\">,</span>\n                                     <span class=\"n\">precision_digits</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"n\">mz</span><span class=\"o\">=</span><span class=\"n\">mz</span><span class=\"p\">,</span> <span class=\"n\">intensity</span><span class=\"o\">=</span><span class=\"n\">intensity</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>I was wondering if this can be done even faster.\nDo you read spectra in Python, or do you have some C library underneath?</p>\n<p>If it's the latter, then it might be worthwile to write a generator in C and expose it to Python using CFFI.</p>\n<p>Sorry for the code that is not reduced for the post, but I guess you can understand what I want to do anyway :)</p>\n<p>Best wishes!</p>", "type": "rendered"}, "created_on": "2017-11-17T16:28:18.188061+00:00", "user": {"display_name": "Matteo Lacki", "uuid": "{0aa740a7-9fa8-4a45-ad13-18e05528160e}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D"}, "html": {"href": "https://bitbucket.org/%7B0aa740a7-9fa8-4a45-ad13-18e05528160e%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/696a8c1520b815233582aa1bf923a809d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsML-5.png"}}, "nickname": "Mateusz \u0141\u0105cki", "type": "user", "account_id": "557058:aa1b63e0-6c01-4920-aa1a-b9e9368b25b2"}, "updated_on": null, "type": "issue_comment", "id": 41283133}