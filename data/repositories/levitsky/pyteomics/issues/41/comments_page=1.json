{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/41/comments/52472033.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/41#comment-52472033"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/41.json"}}, "type": "issue", "id": 41, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "mgf-files containing two spectra with the same title report only the second occurence"}, "content": {"raw": "Hi,\n\nindeed, the indexing is implemented so that the index is kept as a dictionary with spectrum IDs as keys, so they must be unique, or information will be lost. I don\u2019t think this implementation should be changed because in the use case you are describing, there is not so much you can do with the index anyway. Why do you want to use the indexed parser? Do you need positional indexing?\n\nIn theory, you can re-implement some of the indexing machinery to have the index stored as a list instead of a dict. This will look something like this:\n\n```python\nfrom pyteomics import mgf, auxiliary as aux\n\nclass ListIndexedTextReader(aux.IndexedTextReader):\n    def build_byte_index(self):\n        index = []\n        g = self._generate_offsets()\n        last_offset = 0\n        last_label = None\n        for offset, label, keyline in g:\n            if last_label is not None:\n                index.append((last_offset, offset))\n            last_label = label\n            last_offset = offset\n        assert last_label is None\n        return index\n\nclass ListIndexMGF(ListIndexedTextReader, mgf.IndexedMGF):\n    @aux._keepstate_method\n    def _read_header(self):\n        try:\n            first = next(v for v in self._offset_index)[0]\n        except StopIteration: # the index is empty, no spectra in file\n            first = -1\n        header_lines = self.read(first).decode(self.encoding).split('\\n')\n        return self._read_header_lines(header_lines)\n\n    def _read(self, **kwargs):\n        for offsets in self._offset_index:\n            spectrum = self._item_from_offsets(offsets)\n            yield spectrum\n\n    def get_by_index(self, index):\n        return self._item_from_offsets(self._offset_index[index])\n```\n\nNow if you create `ListIndexMGF('duplicated_spectrum.mgf')`, you can parse the whole file or use positional indexing. Other methods may need to be implemented if you want to do something else with it.", "markup": "markdown", "html": "<p>Hi,</p>\n<p>indeed, the indexing is implemented so that the index is kept as a dictionary with spectrum IDs as keys, so they must be unique, or information will be lost. I don\u2019t think this implementation should be changed because in the use case you are describing, there is not so much you can do with the index anyway. Why do you want to use the indexed parser? Do you need positional indexing?</p>\n<p>In theory, you can re-implement some of the indexing machinery to have the index stored as a list instead of a dict. This will look something like this:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">pyteomics</span> <span class=\"kn\">import</span> <span class=\"n\">mgf</span><span class=\"p\">,</span> <span class=\"n\">auxiliary</span> <span class=\"k\">as</span> <span class=\"n\">aux</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ListIndexedTextReader</span><span class=\"p\">(</span><span class=\"n\">aux</span><span class=\"o\">.</span><span class=\"n\">IndexedTextReader</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">build_byte_index</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_generate_offsets</span><span class=\"p\">()</span>\n        <span class=\"n\">last_offset</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">last_label</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n        <span class=\"k\">for</span> <span class=\"n\">offset</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"p\">,</span> <span class=\"n\">keyline</span> <span class=\"ow\">in</span> <span class=\"n\">g</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">last_label</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">last_offset</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">))</span>\n            <span class=\"n\">last_label</span> <span class=\"o\">=</span> <span class=\"n\">label</span>\n            <span class=\"n\">last_offset</span> <span class=\"o\">=</span> <span class=\"n\">offset</span>\n        <span class=\"k\">assert</span> <span class=\"n\">last_label</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span>\n        <span class=\"k\">return</span> <span class=\"n\">index</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ListIndexMGF</span><span class=\"p\">(</span><span class=\"n\">ListIndexedTextReader</span><span class=\"p\">,</span> <span class=\"n\">mgf</span><span class=\"o\">.</span><span class=\"n\">IndexedMGF</span><span class=\"p\">):</span>\n    <span class=\"nd\">@aux._keepstate_method</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_read_header</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"k\">for</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_offset_index</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n        <span class=\"k\">except</span> <span class=\"ne\">StopIteration</span><span class=\"p\">:</span> <span class=\"c1\"># the index is empty, no spectra in file</span>\n            <span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n        <span class=\"n\">header_lines</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">first</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">encoding</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_read_header_lines</span><span class=\"p\">(</span><span class=\"n\">header_lines</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">offsets</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_offset_index</span><span class=\"p\">:</span>\n            <span class=\"n\">spectrum</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_item_from_offsets</span><span class=\"p\">(</span><span class=\"n\">offsets</span><span class=\"p\">)</span>\n            <span class=\"k\">yield</span> <span class=\"n\">spectrum</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">get_by_index</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_item_from_offsets</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_offset_index</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">])</span>\n</pre></div>\n\n\n<p>Now if you create <code>ListIndexMGF('duplicated_spectrum.mgf')</code>, you can parse the whole file or use positional indexing. Other methods may need to be implemented if you want to do something else with it.</p>", "type": "rendered"}, "created_on": "2019-06-06T14:52:09.821810+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": null, "type": "issue_comment", "id": 52472033}, {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/41/comments/52653491.json"}, "html": {"href": "#!/levitsky/pyteomics/issues/41#comment-52653491"}}, "issue": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics/issues/41.json"}}, "type": "issue", "id": 41, "repository": {"links": {"self": {"href": "data/repositories/levitsky/pyteomics.json"}, "html": {"href": "#!/levitsky/pyteomics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3f6302de-10da-4d3c-b258-0bb6a2368972}ts=74456"}}, "type": "repository", "name": "pyteomics", "full_name": "levitsky/pyteomics", "uuid": "{3f6302de-10da-4d3c-b258-0bb6a2368972}"}, "title": "mgf-files containing two spectra with the same title report only the second occurence"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2019-06-19T13:23:18.746665+00:00", "user": {"display_name": "Lev Levitsky", "uuid": "{eb44325f-4ee0-4e0b-a27c-f2ea23122a56}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D"}, "html": {"href": "https://bitbucket.org/%7Beb44325f-4ee0-4e0b-a27c-f2ea23122a56%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a2593c44c42429c503d2e5e9e307e241d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLL-6.png"}}, "nickname": "levitsky", "type": "user", "account_id": "557058:986c547b-c50a-40b3-948a-29b4a93b7b30"}, "updated_on": null, "type": "issue_comment", "id": 52653491}], "page": 1, "size": 2}